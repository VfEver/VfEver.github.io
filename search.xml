<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis数据结构与原理</title>
    <url>/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、缓存"><a href="#一、缓存" class="headerlink" title="一、缓存"></a>一、缓存</h2><h3 id="1-1，缓存的概念"><a href="#1-1，缓存的概念" class="headerlink" title="1.1，缓存的概念"></a>1.1，缓存的概念</h3><p>缓存的概念很广泛，依据用途不同可以分为：</p>
<ol>
<li>操作系统磁盘的缓存：减少磁盘操作</li>
<li>数据库缓存：减少磁盘IO</li>
<li>应用程序缓存：减少数据库访问</li>
<li>Web服务器缓存：减少服务器访问</li>
<li>客户端浏览器缓存：减少网页访问</li>
</ol>
<p>由此我们可以简单认为缓存实际上就是为了减少交互而存在的功能或者组件。</p>
<h3 id="1-2，缓存的意义"><a href="#1-2，缓存的意义" class="headerlink" title="1.2，缓存的意义"></a>1.2，缓存的意义</h3><p>由以上缓存的用途我们可以知道，缓存意义重大，用于减少互相之间的交互提升效率，本质上是热点数据或者临时数据有了一个就近或者效率高的备份。这就引出了一个问题：备份数据和源数据的数据一致性问题。因为你访问数据时是首先访问备份数据（效率原因），数据不存在或者失效再访问源数据。即使缓存存在不止这一个问题，但是由于它的存在带来服务质量以及运作效率的提升，是非常重要不可或缺的。</p>
<h3 id="1-3，关于redis"><a href="#1-3，关于redis" class="headerlink" title="1.3，关于redis"></a>1.3，关于redis</h3><p>我们常见的缓存大致可以分为应用内缓存和组件缓存。应用内缓存有java中的Map，组件缓存包含我们常用的redis和MemCache。接下来，我们将从数据类型入手，讲解redis的基本用法和原理分析。</p>
<h2 id="二、redis的数据类型与用法"><a href="#二、redis的数据类型与用法" class="headerlink" title="二、redis的数据类型与用法"></a>二、redis的数据类型与用法</h2><h3 id="2-1，redis的五种数据类型"><a href="#2-1，redis的五种数据类型" class="headerlink" title="2.1，redis的五种数据类型"></a>2.1，redis的五种数据类型</h3><p>redis分为五种数据类型：</p>
<ol>
<li>string（字符串）</li>
<li>list（链表）</li>
<li>hash（hash）</li>
<li>set（集合）</li>
<li>sorted-set（有序集合）</li>
</ol>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-datatype.png" alt="redis-datatype"></p>
<h3 id="2-2，数据类型的基本用法"><a href="#2-2，数据类型的基本用法" class="headerlink" title="2.2，数据类型的基本用法"></a>2.2，数据类型的基本用法</h3><h4 id="2-2-1-string"><a href="#2-2-1-string" class="headerlink" title="2.2.1 string"></a>2.2.1 string</h4><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-string.png" alt="redis-string"></p>
<h4 id="2-2-2-list"><a href="#2-2-2-list" class="headerlink" title="2.2.2 list"></a>2.2.2 list</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-list.png" alt="redis-list"></p>
<h4 id="2-2-3-hash"><a href="#2-2-3-hash" class="headerlink" title="2.2.3 hash"></a>2.2.3 hash</h4><p>Redis hash 是一个键值(key=&gt;value)对集合；是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-hash.png" alt="redis-hash"></p>
<h4 id="2-2-4-set"><a href="#2-2-4-set" class="headerlink" title="2.2.4 set"></a>2.2.4 set</h4><p>Redis的Set是string类型的无序集合。和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-set.png" alt="redis-set"></p>
<h4 id="2-2-5-sorted-set"><a href="#2-2-5-sorted-set" class="headerlink" title="2.2.5 sorted-set"></a>2.2.5 sorted-set</h4><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。sorted-set是插入有序的，即自动排序。</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-sorted-set.png" alt="redis-sorted-set"></p>
<h2 id="三、redis数据结构原理"><a href="#三、redis数据结构原理" class="headerlink" title="三、redis数据结构原理"></a>三、redis数据结构原理</h2><h3 id="3-1，简单动态字符串（SDS）"><a href="#3-1，简单动态字符串（SDS）" class="headerlink" title="3.1，简单动态字符串（SDS）"></a>3.1，简单动态字符串（SDS）</h3><h4 id="3-1-1，结构定义"><a href="#3-1-1，结构定义" class="headerlink" title="3.1.1，结构定义"></a>3.1.1，结构定义</h4><p>redis中的字符串是最基本数据类型，所有的字符串（各类数据类型的key值、最基本字符串元素值等）内部都是通过SDS（简单动态字符串）来保存的。下面是SDS在redis中的结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> len;			<span class="comment">//记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;			<span class="comment">//记录buf数组中未使用字节的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">char</span> buf[];		<span class="comment">//字节数组，用于保存字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过代码定义我们可以知道，redis中sds通过len、free、buf来表示一个字符串。其中len记录为字符串长度，free记录未使用字节长度，字节数组buf来记录当前实际存储的值。通过图示我们可以看到字符串“redis”在sds中的表示：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-sdshdr.png" alt="redis-sdshdr"></p>
<p>sds中使用buf字节数组存放字符串”redis”，由于”redis”本身占用5个字节，所以字符串长度len为5，没有剩余空间free为0。buf字节数组中我们可以看到，和标准C字符串以空字符结尾一样’\0’。下面展示了另外一个sds示例，与刚才这个sds保存的数据一致，区别在于下面这个sds分配了未使用的空间：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-sdshdr-1.png" alt="redis-sdshdr"></p>
<h4 id="3-1-2，优点"><a href="#3-1-2，优点" class="headerlink" title="3.1.2，优点"></a>3.1.2，优点</h4><p>通过上述sds结构定义和示例我们可以对比出redis的sds相对于C语言中普通字符串优点：</p>
<ol>
<li>O(1)复杂度获取字符串长度。由于sds结构内定义了len字段，可以直接获取当前字符串长度。</li>
<li>杜绝缓冲区溢出。sds api在对字符串进行操作（添加等需要字节空间）时，会先检查剩余空间（free字段）是否符合操作需求，如果不符合，则先对字符串进行扩容操作。</li>
<li>减少修改字符串带来的内存重分配次数。<ol>
<li>空间预分配。当对sds的字符串进行修改并且需要进行扩容时，程序不仅会分配修改所需要的空间，还会为sds分配额外未使用的空间。通过空间预分配，减少连续执行字符串增长操作所需内存重分配次数。</li>
<li>惰性空间释放。当sds需要缩短保存的字符串时，空闲出来的字节数量不立马释放，而是先用free记录起来，并等待将来使用。同时也提供了相应的api让我们可以真正释放sds的未使用空间。</li>
</ol>
</li>
<li>二进制安全。sds的api处理字符串时，都是以二进制形式来处理，并不会像C语言一样遇到空字符就认为是字符串的结束。数据写入是什么样的，读出来就是什么样的。redis并不是单纯使用sds保存字符，而是保存二进制数据。</li>
</ol>
<h3 id="3-2，链表"><a href="#3-2，链表" class="headerlink" title="3.2，链表"></a>3.2，链表</h3><h4 id="3-2-1，结构定义"><a href="#3-2-1，结构定义" class="headerlink" title="3.2.1，结构定义"></a>3.2.1，结构定义</h4><p>链表提供了高效的节点重排能力，以及顺序性节点访问方式。作为一种常用的数据结构，redis自己构建了链表的实现。</p>
<p>使用listNode作为链表节点的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>		<span class="comment">//指向前一个节点的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指向后一个节点的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> *value;							<span class="comment">//节点的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; listNode;</span></pre></td></tr></table></figure>

<p>多个listNode组成双端链表，如下所示：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-listNode.png" alt="redis-listNode"></p>
<p>在此基础上，redis利用list将链表整个结构表现出来，list定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    listNode *head;													<span class="comment">//指向表头节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    listNode *tail;													<span class="comment">//指向表尾巴节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);								<span class="comment">//节点值复制函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);								<span class="comment">//节点值释放函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);			<span class="comment">//节点值对比函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;											<span class="comment">//链表所包含节点数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="built_in">list</span>;</span></pre></td></tr></table></figure>

<p>由一个list和多个listNode组成的图示如下，通过list结构，可以发现对链表操作更加方便</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-list-struct.png" alt="redis-list-struct"></p>
<h4 id="3-2-2，优点"><a href="#3-2-2，优点" class="headerlink" title="3.2.2，优点"></a>3.2.2，优点</h4><ol>
<li>双端。链表节点有prev和next指针，获取某个节点的前置节点和后置节点复杂度都是O(1)。</li>
<li>无环。表头节点的prev和表尾节点的next指向NULL，顺序访问节点通过NULL结束。</li>
<li>list结构带表头head和表尾tail指针。可以迅速访问表头节点和表尾节点。</li>
<li>O(1)时间复杂度获取链表节点长度。</li>
</ol>
<h3 id="3-3，字典"><a href="#3-3，字典" class="headerlink" title="3.3，字典"></a>3.3，字典</h3><h4 id="3-3-1-结构定义"><a href="#3-3-1-结构定义" class="headerlink" title="3.3.1 结构定义"></a>3.3.1 结构定义</h4><p>字典是一个映射（map），一种用于保存键值对的抽象数据结构。在字典中，一个键key和一个值value进行关联，称之为键值对。字典中每个键都是独一无二的，不允许重复。redis构建了自己的字典实现，使用哈希表作为底层实现。一个哈希表里面可以有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对。</p>
<p>hash表节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> *key;								<span class="comment">//键值对的键</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> *val;								<span class="comment">//键值对的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>		<span class="comment">//指向下一个键值对的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; dictEntry;</span></pre></td></tr></table></figure>

<p>dictEntry定义了键值对的键和值，同时还包含有指向下一个键值对dictEntry的指针。为什么会有下一个键值对的指针呢？是因为当计算出的hash值出现冲突的时候，字典通过链地址法解决冲突。</p>
<p>hash表定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dictEntry **table;			<span class="comment">//存储dictEntry节点的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;			<span class="comment">//hash表大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;	<span class="comment">//hash表大小掩码，用于计算索引值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;			<span class="comment">//已经存在的节点数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; dictht;</span></pre></td></tr></table></figure>

<p>table是一个数组，数组中的每个元素都是指向dictEntry的指针。size记录了hash表的大小。sizemask作为掩码用于计算每个dictEntry的下标值，大小等于hash表大小size-1。used代表hash表上节点的数量。下图展示了一个大小为4的空hash表：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-dict-empty.png" alt="redis-dict-empty"></p>
<p>有两个元素且两个元素冲突的hash表图示：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-dict-used.png" alt="redis-dict-used"></p>
<p>redis中字典定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dictType *type;		<span class="comment">//类型特定函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> *privdata;		<span class="comment">//私有数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dictht ht[<span class="number">2</span>];			<span class="comment">//哈希表数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> rehashidx;		<span class="comment">//rehash索引，索引不再进行时rehashidx=-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; dict;</span></pre></td></tr></table></figure>

<p>下面图示为有两个键值对节点的字典：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/redis-dict.png" alt="redis-dict"></p>
<h3 id="3-3-2，优点"><a href="#3-3-2，优点" class="headerlink" title="3.3.2，优点"></a>3.3.2，优点</h3><ol>
<li><p>哈希算法。使用字典设置的哈希函数计算键key的hash值，然后根据hash值计算下标索引值。</p>
<p>hash=dict-&gt;type-&gt;hashFunction(key)</p>
<p>index=hash&amp;dict-&gt;ht[x].sizemask</p>
</li>
<li><p>解决键冲突。当计算出来的index值和当前hash表中的键冲突时，通过链地址法来解决冲突。即将新节点添加到链表的表头位置，排在其他已有节点的前面。</p>
</li>
<li><p>rehash。</p>
<ol>
<li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量(ht[0].used)：<ol>
<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[1].used*2的2<sub>n</sub>(2的n次方幂)</li>
<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2<sub>n</sub>。</li>
</ol>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li>
<li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，ht[0]这时已经是一个空表，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]上新创建一个空白哈希表，为下次rehash作准备。</li>
</ol>
</li>
<li><p>渐进式hash。为了避免rehash对服务器性能造成的影响，服务器并不是一次性将ht[0]里面所有的键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。渐进式哈希餐区分而治之的策略，将rehash键值对所需的计算工作均摊到对字典每个添加、删除、查找和更新的操作上，从而避免了集中式rehash而带来的庞大计算量。在执行rehash期间，rehashidx记录当前已经执行了rehash的原table下标。</p>
</li>
</ol>
<h3 id="3-4，跳跃表"><a href="#3-4，跳跃表" class="headerlink" title="3.4，跳跃表"></a>3.4，跳跃表</h3><h4 id="3-4-1，结构定义"><a href="#3-4-1，结构定义" class="headerlink" title="3.4.1，结构定义"></a>3.4.1，结构定义</h4><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。支持平均O(logN)、最坏O(N)复杂度的节点查找，效率可以和平衡树相媲美，并且实现起来比红黑树更为简单。</p>
<p>redis中跳跃表中节点的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> score; 										<span class="comment">//节点保存的分值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>		<span class="comment">//后退指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>	<span class="comment">//前进指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;							<span class="comment">//跨度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; level[];													<span class="comment">//层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; zskiplistNode;</span></pre></td></tr></table></figure>

<p>跳跃表使用<em>zskiplistNode</em>作为有序表中的一个节点。节点中有保存的分值，指向上一个节点的后退指针，以及整个节点的层。每层保存了指向下一个节点的指针以及跨度。</p>
<p>跳跃表节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>	<span class="comment">//头节点、尾巴节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;									<span class="comment">//表中节点的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> level;														<span class="comment">//表中层数最大的节点的层数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; zskiplist;</span></pre></td></tr></table></figure>

<p>zskiplist持有了整个跳跃表的头节点和尾节点的指针，同时还保存了跳跃表中节点的数量和层数最大节点的层数。下图展示了有3个跳跃表节点且最高层数为5的跳跃表：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/skiplist.png" alt="redis-dict"></p>
<h4 id="3-4-2，优点"><a href="#3-4-2，优点" class="headerlink" title="3.4.2，优点"></a>3.4.2，优点</h4><ol>
<li>通过zskiplist持有头尾节点，可以快速到达头尾节点，且能够获取节点的个数。</li>
<li>节点存储了值，且节点是按照值的大小顺序链表存贮。</li>
<li>每个节点层数随机生成。每层持有下一跳或者下几跳的节点和跨度，可以迅速跳到对应节点。</li>
<li>查找平均O(logN)、最坏O(N)时间复杂度，媲美红黑树且比红黑树实现起来简单。</li>
</ol>
<h3 id="3-5，整数集合"><a href="#3-5，整数集合" class="headerlink" title="3.5，整数集合"></a>3.5，整数集合</h3><h4 id="3-5-1，结构定义"><a href="#3-5-1，结构定义" class="headerlink" title="3.5.1，结构定义"></a>3.5.1，结构定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">uint32_t</span> encoding;			<span class="comment">// 编码类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">uint32_t</span> length;				<span class="comment">// 集合包含元素的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int8_t</span> contents[];			<span class="comment">// 保存元素的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; intset;</span></pre></td></tr></table></figure>

<p>从intset的结构定义中我们可以知道，包含了一个编码类型，编码类型指定了contents数组里面保存元素的编码；同时intset还持有了集合包含元素数量的length。</p>
<p>整数集合<em>intset</em>是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为集合键的底层实现。图示如下：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/intset.png" alt="redis-intset"></p>
<p>inset记录了元素的编码值，当目前的编码值不允许存放更大的元素，占用位数更多的元素要进行插入时，根据新元素的类型，扩展整数集合底层数组空间大小；将contents里面每个元素转化成与新元素相同的类；将新元素插入到底层数组。</p>
<h4 id="3-5-2，重点回顾"><a href="#3-5-2，重点回顾" class="headerlink" title="3.5.2，重点回顾"></a>3.5.2，重点回顾</h4><ol>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合底层实现为数组，这个数组以有序、无重复的方式保存集合元素，再有需要时，程序会根据新添加元素的类型改变数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作，不支持降级操作。</li>
</ol>
<h3 id="3-6，压缩列表"><a href="#3-6，压缩列表" class="headerlink" title="3.6，压缩列表"></a>3.6，压缩列表</h3><h4 id="3-6-1，结构定义"><a href="#3-6-1，结构定义" class="headerlink" title="3.6.1，结构定义"></a>3.6.1，结构定义</h4><p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键包含少量列表项，并且每个列表项要么是小整数值，要么是比较短的字符串，那么redis就会使用压缩列表来做列表键的底层实现。下面看一下压缩列表的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> zl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>redis中的压缩列表没有明确的定义，通过<em>ziplistNew</em>创建一个新的<em>ziplist</em>，我们可以大致画出它的内存结构：</p>
<p><img src="/2020/02/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/ziplist.png" alt="redis-ziplist"></p>
<p>各个字段代表的含义如下：</p>
<ol>
<li>zlbytes：记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或者计算zlend位置时使用。</li>
<li>zltail：记录压缩列表尾节点距离压缩列表起始地址有多少字节，通过这个字段可以计算出尾节点的位置。</li>
<li>zlen：记录了压缩列表包含的节点数量。</li>
<li>entryX：压缩列表的节点，真正保存数据。</li>
<li>zlend：特殊值0xFF，用于标记压缩列表的末端。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos算法原理与推导</title>
    <url>/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h2 id="一、Paxos介绍"><a href="#一、Paxos介绍" class="headerlink" title="一、Paxos介绍"></a>一、Paxos介绍</h2><p>我们常见的分布式系统中，总会发生网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）、机器宕机等异常情况。如何才能保证在发生诸如此类问题的情况下，快速且正确的在集群内部对某个数据的值达成一致，不会破坏系统的一致性，这就需要Paxos算法的支撑。</p>
<p>Paxos算法是莱斯特-兰伯特与1990年提出的一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。接下来将一步一步推导Paxos，做到不仅要理解Paxos的选举步骤，更要理解推导证明过程。理解算法的核心和精髓，是对我们思想的一种锻炼，对以后工作中解决问题有一定的帮助。</p>
<h2 id="二、背景-amp-解决的问题"><a href="#二、背景-amp-解决的问题" class="headerlink" title="二、背景&amp;解决的问题"></a>二、背景&amp;解决的问题</h2><p>如上述提到，分布式系统中，如果出现网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）、机器宕机等异常情况时，容易造成各个节点数据不一致的情况。如下图所示：</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/methine_down.png" alt="down"></p>
<p>机器宕机、网络异常等，导致消息不可达等异常流程，会造成数据不一致的情况。比如未收到消息的节点与其他节点数据不一致，宕机机器重启后数据不一致以及恢复策略等。也就是面对如下异常问题时，算法需要保证的就是，对某个数据的值达成最终一致。</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/issures.png" alt="issure"></p>
<h2 id="三、概念-amp-定义"><a href="#三、概念-amp-定义" class="headerlink" title="三、概念&amp;定义"></a>三、概念&amp;定义</h2><h3 id="3-1，角色类型"><a href="#3-1，角色类型" class="headerlink" title="3.1，角色类型"></a>3.1，角色类型</h3><p>Paxos算法模型中定义了三种角色类型：</p>
<ol>
<li>Proposer，模型中的提议者，作用是提出建议。</li>
<li>Acceptor，模型中的批准者，作用是针对提议者的提议进行接受批准。</li>
<li>Learner，模型中的学习者，也就是会从批准者获取数据并应用。</li>
</ol>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/role.png" alt="role"></p>
<p>需要注意的一点就是，模型中三种角色类型，并不是一开始就完全定死的。每一个节点并不止一种角色类型，可以即是提议者，又是批准者，还作为学习者获取数据应用。这一点理解起来不难，想象这么一个场景，Zookeeper集群中，在开始启动选主的过程中，每一个服务节点并不是单纯的提议者或者批准者（zk中节点类型并不是这么定义，但是核心算法是Paxos）。如下图所示，每一个node在发起自己的投票的时候为Proposer，接收到投票后做决策时为Acceptor（类似Acceptor）。</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/role_example.png" alt="node_example"></p>
<h3 id="3-2，提案（Proposal）"><a href="#3-2，提案（Proposal）" class="headerlink" title="3.2，提案（Proposal）"></a>3.2，提案（Proposal）</h3><p>Proposer提出请求，Acceptor针对此请求作出响应。这个由proposer产生的请求，我们称之为提案——Proposal。Proposal由两部分组成，提案编号和提案值。提案编号可以理解为Proposer发起提案的一个唯一标识；提案值则代表此次提案投票选定的值。为什么提案包含两部分内容（编号+值）？只有编号或者只有值可不可以？下面在算法的推导过程中，会具体讲解这些疑问。提案的表示定义为：Proposal(N,V)。</p>
<h2 id="四、问题描述"><a href="#四、问题描述" class="headerlink" title="四、问题描述"></a>四、问题描述</h2><p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：</p>
<ul>
<li>在这些被提出的提案中，只有一个会被选定。</li>
<li>如果没有提案被提出，那么就不会有被选定的提案。</li>
<li>当一个提案被选定后，进程应该可以获取被选定的提案信息。</li>
</ul>
<p>相对于一致性的需求来说，算法的安全性定义如下：</p>
<ul>
<li>只有被提出的提案才能被选定。</li>
<li>只能有一个值被选定。</li>
<li>如果某个进行获取到某个提案被选定，那么这个提案必须是真正被选定的那个。</li>
</ul>
<p>同时我们需要对问题的复杂性做一些定义：</p>
<ul>
<li>每个节点角色不是固定的，可能是Proposer、Acceptor、Leaner。</li>
<li>每个节点运行的速率是不固定的，也就是在发起提案、作出决策的时间是不固定的。</li>
<li>每个节点可能因为机器问题宕机、重启。</li>
<li>消息在传输过程中由于网络问题丢失、重复、延迟。但是消息不会被损坏（发送和接受到的消息肯定是完全完整的）。</li>
</ul>
<p>阐述完整体问题描述，接下来我们将针对此问题的算法进行推导。</p>
<h2 id="五、-算法推导"><a href="#五、-算法推导" class="headerlink" title="五、 算法推导"></a>五、 算法推导</h2><p>要满足提出个提案有一个被选定，我们可以先假定只有一个Acceptor。当Proposer提出提案，并且此Acceptor收到提案，就批准该提案。这样不会出现到底哪个提案会被选定还是是否还存在商议的过程。但是这样也出现了一个问题，那就是当这个Acceptor挂掉宕机，那就失去了可靠性的保证，也就没有任何意义。</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/acceptor_down.png" alt="acceptor down"></p>
<p>所以我们选定一组节点作为Acceptor，Proposer向一组Acceptor发送提案，那么我们就要讨论这一组Acceptor如何决议出最后一个提案。另外我们规定每一个Acceptor最多只能批准一个提案，那么就能保证只有一个提案被选定。</p>
<h3 id="5-1，多个Accptor"><a href="#5-1，多个Accptor" class="headerlink" title="5.1，多个Accptor"></a>5.1，多个Accptor</h3><p>为了使算法推导、理解简单，我们先假定有一组Proposer和一组Acceptor，两组角色定义不会更改（实际在系统运转过程中，每一个进程或者每一个节点，可能为Proposer或Acceptor）。Proposer组向Acceptor组发起提案，Acceptor组批准提案。如下：</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/mutil.png" alt="mutil"></p>
<p>Proposer集合中的每个节点向Acceptor集合中的每个节点发送提案请求，请求可能有延迟、重复、不可达，怎么保证批准一个提案呢？于是我们定义以下一个原则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原则P1:一个Acceptor必须批准它接受到第一个提案。</span></pre></td></tr></table></figure>

<p>基于此原则，Acceptor收到Proposer发出的提案，如果是第一个，则批准。这就保证了最后肯定会有提案批准成功。但是又产生了另外一个问题，那就是多个Proposer分别提出提案到不同的Acceptor，那么就出现了多个提案都被批准的情况，违背我们的安全性原则。</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/mutil_fail.png" alt="mutil_fail"></p>
<p>或者出现如下异常case（其中一个Acceptor宕机，导致P1、P2提出的提案分别被相同数量的Acceptor批准）：</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/mutil_err_same.png" alt="mutil_err_same"></p>
<p>由于我们定了“Acceptor必须接受它接受的第一个提案”，但是上述两个异常情况，导致最终可能会有多个提案被选定，所以我们需要加一个规定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">规定：一个提案被选定需要被半数以上的Acceptor接受。</span></pre></td></tr></table></figure>

<p>当Acceptor组中绝大多数Acceptor批准一个提案的时候，我们就认为这个提案被选定。绝大多数定义为本组Acceptor数量的一半以上，任意两个一半以上的子集肯定包含有至少一个公共成员Acceptor。因为这个规定，所以意味着每个Acceptor可能需要批准多个提案，不然类似上述异常case情况下，约束为每个Acceptor只能批准一个，那么最终不会有唯一一个最终提案产生。</p>
<h3 id="5-2，提案-Proposal-amp-批准-Accept-升级"><a href="#5-2，提案-Proposal-amp-批准-Accept-升级" class="headerlink" title="5.2，提案(Proposal)&amp;批准(Accept)升级"></a>5.2，提案(Proposal)&amp;批准(Accept)升级</h3><p>开始第一阶段我们的提案可以认为只是单纯的一个编号，Acceptor批准提案批准的只是这个提案的编号。但是由于提案的最终选定需要多数Acceptor批准，所以每个Proposer提出的提案，需要得到超过半数的Acceptor的批准，若没有超过半数，需要再次发起一次提案，这时就需要重新发起的提案更换提案编号。更换编号的策略，简单直接点就是每次每个Proposer产生一个新的提案，所属编号为<strong>全局</strong>递增。编号生成器规则这里不再阐述。</p>
<p>从Acceptor角度讲，由于允许可以批准多次提案，但是由于需要保证一个提案产生，所以需要对Acceptor的多次批准做一个限制，规定如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">规定：一个Acceptor不能批准编号小于它已经响应过的所有提案中编号最大的编号值。</span></pre></td></tr></table></figure>

<p>什么意思呢？假设Acceptor A，已经对收到的提案编号（4，5）作出过响应（Acceptor需要记录它批准过的提案中最大的提案编号），这时由于网络延迟等问题，来了一个编号为3的提案，A对这个提案直接返回error或者忽略这个提案。此时发出提案的Proposer收到了error或者没收到对它提案的响应（非ok的响应），那么也就意味着它丧失了对应Acceptor的表决。</p>
<p>我们通过从Proposer和Acceptor角度分析得出：</p>
<ol>
<li>提案编号全局递增</li>
<li>Acceptor可以批准多个提案但是不能批准编号小于它已经批准过的最大的提案编号</li>
</ol>
<p>这样我们解决了一个提案怎么才能让大多数Acceptor批准的问题，但是并没有解决大多数Acceptor对所收到的提案达成最终一致的问题。继续从Acceptor和Proposer来看，我们可以得出，每个角色只是单独负责自己的职责功能，对彼此的交互并没有一个统一协调的进步。Acceptor只管负责批准提案，Proposer只管负责产生提案。所以我们就需要要求Acceptor和Proposer进一步加强交互，做到信息互通。</p>
<p>我们对Proposer产生的提案作出如下定义，Proposal由两部分内容组成，编号和值。也就是Proposal(N,V)。N代表本次提案的编号，V代表本次提案的值。提案的值V就是Acceptor和Proposer多次交互最终需要达成一致的值。</p>
<h3 id="5-3，算法原则推导"><a href="#5-3，算法原则推导" class="headerlink" title="5.3，算法原则推导"></a>5.3，算法原则推导</h3><p>上述提到，我们允许多个提案被选定，但是同时必须保证所有被选定的提案都必须拥有相同的V值。对于提案value值的约定，结合提案编号，我们有如下原则：</p>
<p>P2:如果编号为 M<sub>0</sub> 、Value值为V<sub>0</sub> 的提案（即[M<sub>0</sub>,V<sub>0</sub> ]）被选定了，那么所有比编号M<sub>0</sub>更高的，且被选定的提案，其Value值也必须是V<sub>0</sub>。</p>
<p>一个提案要被选定，首先必须被至少一个Acceptor批准，因此我们可以通过满足如下条件来满足P2。</p>
<p>P2a:如果编号为 M<sub>0</sub> 、Value值为V<sub>0</sub> 的提案（即[M<sub>0</sub>,V<sub>0</sub> ]）被选定了，那么所有比编号M<sub>0</sub>更高的，且被Acceptor批准的提案，其Value值也必须是V<sub>0</sub>。</p>
<p>到目前为止，我们通过P1、P2可以保证有一个提案会被选定，但是还会存在这样一个问题。由于Proposer和Acceptor的通信涉及到网络延迟，很可能出现某个Proposer提出的提案已经被大多数Acceptor选定，另外一个Proposer又提出一个其他value值且编号比被选定提案编号还高的提案，同时从未批准过任何提案的Acceptor A接收到了，根据P1，此Acceptor A必须批准该提案。这就出现了Acceptor A批准的提案和其他Acceptor批准的不一致，违反了P2a原则。如下图所示：</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/p2a_error.png" alt="p2a_error"></p>
<p>因此我们需要针对P2a进行强化：</p>
<p>P2b:如果一个提案[M<sub>0</sub>,V<sub>0</sub> ]被选定后，那么之后任何Proposer产生的编号更高的提案，其value值都为V<sub>0</sub> 。</p>
<p>通过P2b，我们可以推导出P2a，进而也可以推导出P2。</p>
<p>如何保证某个Value为v的提案被选定后，Proposer提出的编号更高提案的value都是v呢？可以通过第二数学归纳法证明。假设：</p>
<ul>
<li>编号在M<sub>0</sub>到M<sub>n-1</sub>之间的提案，其Value的值都是V<sub>0</sub>，证明编号为M的提案的Value值也为V<sub>0</sub>。</li>
</ul>
<p>因为编号为M<sub>0</sub>的提案已经被选定了，这就意味着肯定存在一个由半数以上的Acceptor组成的集合C，C中的每个Acceptor都批准了该提案。在结合假设，编号为M<sub>0</sub>的提案被选定意味着：</p>
<ul>
<li>C中的每一个Acceptor都批准了一个编号在M<sub>0</sub>到M<sub>n-1</sub>范围内的提案，并且每个编号在M<sub>0</sub>到M<sub>0-1</sub>范围内的都被Acceptor批准的提案，其Value值都为V<sub>0</sub>。</li>
</ul>
<p>我们再定义一个存在半数以上Acceptor的集合S，S中肯定包含且至少包含C中的一个成员，因此我们可以认为如果保证了如下P2c的不变性，那么编号为M<sub>n</sub>的提案的Value也为V<sub>0</sub>.</p>
<p>P2c:对于任意的M<sub>n</sub>和V<sub>n</sub>，如果提案[M<sub>n</sub>,V<sub>n</sub>]被提出，那么肯定存在一个半数以上的集合S，满足以下任意一点：</p>
<ol>
<li>S中不存在任何批准过编号小于M<sub>n</sub>的提案的Acceptor。</li>
<li>选取S中所有Acceptor批准的编号小于M<sub>n</sub>的提案，其中编号最大的那个提案其Value值是V<sub>n</sub>。</li>
</ol>
<p>我们通过P2c可以知道每个Proposer如何产生一个提案：对于产生的每个提案[M<sub>n</sub>,V<sub>n</sub>]，需要满足以下条件：</p>
<p>存在一个由半数以上Acceptor组成的集合S：</p>
<ol>
<li>要么S中没有Acceptor批准过任何提案，那么S接收到任何提案，都会直接批准。</li>
<li>要么S中所有Acceptor批准的所有编号小于M<sub>n</sub>的提案中，编号最大的那个提案的Value值为V<sub>n</sub>。</li>
</ol>
<p>我们接下来使用第二数学归纳法来证明。首先假设提案[M<sub>0</sub>,V<sub>0</sub>]被选定了，那么比这个提案编号大的提案[M<sub>n</sub>,V<sub>n</sub>]，我们需要证明在P2c的前提下，对于所有的[M<sub>n</sub>,V<sub>n</sub>]，存在V<sub>n</sub>=V<sub>0</sub>。</p>
<ol>
<li>当M<sub>n</sub>=M<sub>0+1</sub>时，如果有这样一个编号为M<sub>n</sub>的提案，首先我们知道[M<sub>0</sub>,V<sub>0</sub>]已经被选定了，那么就一定存在一个Acceptor的子集S，且S中的Acceptor已经批准了小于M<sub>n</sub>的提案，于是V<sub>n</sub>只能是批准的所有编号小于M<sub>n</sub>提案中编号最大提案的Value。此时M<sub>n</sub>=M<sub>0+1</sub>，因此编号小于M<sub>n</sub>的编号只能是M<sub>0</sub>，也就是批准的提案为[M<sub>0</sub>,V<sub>0</sub>]。同时由于S和通过[M<sub>0</sub>,V<sub>0</sub>]的Acceptor集合都是多数集，也就是二者肯定至少有一个Acceptor的交集，这样Proposer在确定V<sub>n</sub>取值的时候，就一定会选择V<sub>0</sub>。</li>
</ol>
<p>这是数学归纳法的第一步，证明了n=0+1的情况下，是符合我们预期的。接下来我们就要假设在n=0+1到n=n-1这个区域符合预期，并在此基础上推导出当编号为M<sub>n</sub>也成立。</p>
<ol start="2">
<li>根据假设，编号在M<sub>0+1</sub>到M<sub>n-1</sub>区间内的所有提案的Value值为V<sub>0</sub>，需要证明的是编号为M<sub>n</sub>的提案的Value值也为V<sub>0</sub>。根据P2c，首先同样一定存在一个Acceptor集合S，且S中的Acceptor已经批准了小于M<sub>n</sub>的提案，那么编号M<sub>n</sub>的提案的Value值只能是这个多数集S中编号小与M<sub>n</sub>但为最大编号的那个提案的值。如果这个最大提案编号的值落在M<sub>0+1</sub>到M<sub>n-1</sub>区间，那么Value值肯定是V<sub>0</sub>。如果不落在这个区间，那么它的编号不可能比M<sub>0</sub>更小，肯定就是M<sub>0</sub>，以为S也肯定与批准[M<sub>0</sub>,V<sub>0</sub>]这个提案的Acceptor集合S<sub>1</sub>有交集，而如果编号是M<sub>0</sub>，那么它的Value值也是V<sub>0</sub>。</li>
</ol>
<h3 id="5-4，算法描述"><a href="#5-4，算法描述" class="headerlink" title="5.4，算法描述"></a>5.4，算法描述</h3><p>上文我们提到，要通过加强Proposer和Acceptor之间的交互，来完成最终提案值的选定；同时我们在P2c的推导过程中，确定了Proposer要感知Acceptor的批准的提案的值，也就是Proposer需要有一个拿到Acceptor批准的提案值的环节。于是我们可以将获取最终值分为两个阶段：</p>
<ol>
<li>Proposer发起提案请求，Acceptor处理请求，并有一定的返回。</li>
<li>Proposer处理Acceptor的返回，并进行提案最终值的确认。Acceptor处理Proposer发起的确认，达成一致。</li>
</ol>
<p>专业一点的讲法就是分为Prepare阶段和Acceptor阶段。</p>
<h4 id="5-4-1，Proposer生成提案"><a href="#5-4-1，Proposer生成提案" class="headerlink" title="5.4.1，Proposer生成提案"></a>5.4.1，Proposer生成提案</h4><ol>
<li>Proposer选择一个新的提案编号M<sub>n</sub>，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor作出如下回应<ul>
<li>向Proposer承诺，保证不再批准任何编号小于M<sub>n</sub>的提案。</li>
<li>如果Acceptor已经批准过任何提案，那么就向Proposer反馈当前该Acceptor已经批准的编号小于M<sub>n</sub>但为最大编号的那个提案的值</li>
</ul>
</li>
</ol>
<p>我们将此类请求称之为编号为M<sub>n</sub>提案的Prepare请求。</p>
<ol start="2">
<li>如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为M<sub>n</sub>、Value值为V<sub>n</sub>的提案，这里的V<sub>n</sub>是所有响应中编号最大的提案的Value值。如果半数以上的Acceptor没有批准过任何提案，即响应中不包含任何提案，那么此时V<sub>n</sub>值就可以由Proposer任意选择。</li>
</ol>
<p>Proposer向Acceptor发起请求并期望得到批准，我们称此次请求为Accept请求。</p>
<h4 id="5-4-2，Acceptor批准提案"><a href="#5-4-2，Acceptor批准提案" class="headerlink" title="5.4.2，Acceptor批准提案"></a>5.4.2，Acceptor批准提案</h4><p>由上文内容我们知道，一个Acceptor可能会收到Proposer两种请求，分别是Prepare请求和Accept请求，对这两类请求做出响应的条件如下：</p>
<ul>
<li>Prepare请求：Acceptor可以在任何时候响应一个Prepare请求。</li>
<li>Accept请求：在不违背Accept现有承诺前提下，可以任意响应Accept请求。</li>
</ul>
<p>所以针对Acceptor我们定义以下原则：</p>
<p>P1a:一个Acceptor只要尚未响应过任何编号大于M<sub>n</sub>的Prepare请求，那么它就可以接受这个编号为M<sub>n</sub>的提案。</p>
<p>针对此原则，我们还可以进行优化，那就是针对编号小于M<sub>n</sub>的提案Prepare请求，可以忽略；同样提案编号的Prepare，不再重复响应。接下来我们针对这两阶段Acceptor的动作，做一个描述。</p>
<p><strong>阶段一</strong></p>
<ol>
<li>Proposer选择一个提案编号M<sub>n</sub>，然后向Acceptor的某个超过半数的子集成员发送编号M<sub>n</sub>的Prepare请求。</li>
<li>如果Acceptor收到一个编号为M<sub>n</sub>请求，且编号M<sub>n</sub>大于该Acceptor已经响应的所有Proposer请求编号，那么它会将它已经批准过的最大编号的提案作为响应反馈给Proposer。同时该Acceptor承诺不回再批准任何编号小于M<sub>n</sub>的提案。</li>
</ol>
<p>举例：如果一个Acceptor已经批准过所有Prepare请求对应的提案编号分别为[4、5、6]，那么该Acceptor收到一个编号为7的Prepare请求后，就会将编号为7的提案作为响应返回给Proposer。</p>
<p><strong>阶段二</strong></p>
<ol>
<li>如果Proposer收到半数以上的Acceptor对于其发出的编号为M<sub>n</sub>的prepare请求的响应，那么它就会发送一个针对[M<sub>n</sub>,V<sub>n</sub>]提案的Accept请求给Acceptor。V<sub>n</sub>的值就是收到的响应中编号最大的提案的值。如果响应中不包含任何提案，那么它就是任意值。</li>
<li>如果Acceptor收到这个针对[M<sub>n</sub>,V<sub>n</sub>]提案的Accept请求，只要该Acceptor尚未对编号大于M<sub>n</sub>的Prepare请求做出响应，它就可以通过这个提案。</li>
</ol>
<p>整个算法的执行流程如此，文字表述比较晦涩，我们通过下面这幅图来说明：</p>
<p><img src="/2019/12/26/Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/two_jieduan.png" alt="两阶段"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>从数据结构到MySQL的InnoDb存储引擎</title>
    <url>/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="一、索引的本质"><a href="#一、索引的本质" class="headerlink" title="一、索引的本质"></a>一、索引的本质</h1><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构。简单来讲，索引本身是一种或多种数据结构，目的是为了加速表中数据行的检索。<br>在RDBMS系统中数据的索引都是硬盘级索引。  </p>
<h1 id="二、索引的数据结构"><a href="#二、索引的数据结构" class="headerlink" title="二、索引的数据结构"></a>二、索引的数据结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二叉树是每个结点最多有两个子树的树结构，也称之为二路查找树。可以用于实现二叉查找树和二叉堆）。二叉树图示如下：<br><img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ercha_tree.png" alt="二叉树">  </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>树的高度太高，不是硬盘级别索引。每个结点存储数据和指向磁盘的指针，没有利用好磁盘级别索引的特性，磁盘利用率过低。</li>
<li>没有利用好操作系统跟磁盘交互的特性，没有利用好磁盘IO的预读能力（空间局部性），带来频繁IO。</li>
</ol>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h4 id="阶的概念"><a href="#阶的概念" class="headerlink" title="阶的概念"></a>阶的概念</h4><p>对于一棵m阶的B树，每个结点最多有m个子节点。如下图，这个B树最多的结点有三个子结点，所以它的阶数为3。</p>
<h4 id="度的概念"><a href="#度的概念" class="headerlink" title="度的概念"></a>度的概念</h4><p>度指的是树的高度，也就是树的层数。  下图这个B树高为3，那么也就是说它的度为3。<br> <img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/b_tree.png" alt="B树">  </p>
<h4 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h4><ol>
<li>树中每个结点至多有m棵子树（m为树的阶）</li>
<li>根结点不是不是叶子节点，至少有两棵子树</li>
<li>除根结点之外所有非叶子结点至少有p个子结点（m/2（向上取整） ≤ p ≤ m）</li>
<li>所有的非叶子节点都包含以下数据（n,A0,K1,A1,K2,…,Kn,An）,其中n为关键字个数，Ai为指向叶子结点的指针，Ki为关键字（实际存储的数据），且Ki&lt;Ki+1.</li>
<li>所有的叶子结点都出现在同一层次上，即所有的叶子结点具有相同的深度，等于树高度，并且不带信息。    </li>
</ol>
<p>多路平衡查找数，平衡的意思是左右两边分布均匀；多路是相对于二叉树而言，二叉树就是二路查找树，查找的时候只有两条路，而B树有多条路，父节点有多个子节点。每个结点可以抽象认为是一个磁盘块，包含数据区和指向子结点的指针。根据B树的定义，我们可以画出实际磁盘数据存储过程中的结构图，如下：<br> <img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/b_tree_real.PNG" alt="B树"><br> 在此图中我们可以这么理解，假设寻找X，</p>
<ol>
<li>x&lt;17，命中P1指针</li>
<li>x=17，直接命中</li>
<li>17&lt;x&lt;35，命中P2指针</li>
<li>x=35，直接命中</li>
<li>x&gt;35，命中P3指针</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>由图可以看出，B树作为索引的数据结构，是不适用于范围查询的。因为关键字保存在每个非叶子结点上，每个非叶子结点都可以认为一个磁盘块，范围查询如果跨叶子结点，意味着跨磁盘块。这也就是为什么B树不适合作为索引。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树也是B树的一种，由B树演进而来，主要是为了适配基于磁盘的索引条件。它是如何适配基于磁盘的索引的呢？首先我们需要了解一下B+的定义以及它的优点。</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ol>
<li>左闭右开区间。</li>
<li>有k个子结点必然有k个关键码。  </li>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。  </li>
</ol>
<p><img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/b+tree.PNG" alt="B树"><br>记录数据相关的信息存储在叶结点中，树的所有叶结点构成一个有序链表，按照关键码排序的次序遍历全部记录。<br>B+树与B树不同点在于以上两点，关键字个数和子结点个数，以及非叶子结点的数据存储。  </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>符合InnoDB存储引擎的硬盘级索引方式。IO能力强。</li>
<li>基于索引的扫库、扫表能力强于B树。</li>
<li>范围查询，天然有序。</li>
<li>查询能力较为稳定。  </li>
</ol>
<h1 id="三、Innodb支持的索引"><a href="#三、Innodb支持的索引" class="headerlink" title="三、Innodb支持的索引"></a>三、Innodb支持的索引</h1><p>目前InnoDB存储引擎支持以下方式索引：</p>
<ol>
<li>B+tree</li>
<li>自适应hash索引  </li>
</ol>
<p>除了上文提到的B+树索引，InnoDB还支持hash索引。这个hash索引指的是自适应hash索引。引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，经常访问的二级索引数据会自动被生成到hash索引里面去，自适应哈希索引通过缓冲池的B+树构造而来（B+树的索引，可以称之为索引中的索引），因此建立的速度很快。hash索引的原理过程如下图：  </p>
<p><img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/hash.png" alt="hash索引"></p>
<h1 id="四、索引的内容"><a href="#四、索引的内容" class="headerlink" title="四、索引的内容"></a>四、索引的内容</h1><p>MyISAM索引保存指针地址，主键索引和辅助索引一致。如下图：<br><img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/myisam.png" alt="hash索引"><br>InnoDB索引主键索引保存实际数据（聚簇索引），辅助索引保存主键索引的值（非聚簇索引）。为什么辅助索引不保存主键索引的实际地址？因为随着数据的CUD操作，主键索引的地址也会发生变化。<br>InnoDB索引数据存储如下：<br><img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/b+save.png" alt="hash索引"><br>辅助索引与主键索引的关系如下：<br><img src="/2019/11/12/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B0MySQL%E7%9A%84InnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/b+with.png" alt="hash索引"><br>上文提到InnoDB支持的索引，每种数据结构存储的数据内容不一样。</p>
<ol>
<li>B+树索引，非叶子结点存储关键字和指针信息（指向子结点）；叶子结点存储了数据信息和指向下一个叶子结点的指针。</li>
<li>hash索引存储了二级索引信息和指向实际数据磁盘区块的指针。它是索引中的索引。</li>
</ol>
<h1 id="五、索引的形式"><a href="#五、索引的形式" class="headerlink" title="五、索引的形式"></a>五、索引的形式</h1><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>所谓联合索引，就是由数据库表多个关键字联合起来形成的索引，此类索引是有顺序的（ABC和CBA是两个完全不同的联合索引，本质上是两个不同的B+树）。单列索引可以认为是特殊的联合索引。由于联合索引数据结构也是B+树，所以在使用联合索引进行查询的时候，从左到右、从小到大依次匹配，也就是我们常说的最左前缀原则。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引是指查询列可以通过索引结点中的关键字直接返回。由此可以推断出，主键索引是覆盖索引，因为主键所在的物理磁盘上存储了主键所在行的所有信息。<br>覆盖索引可减少数据库IO。</p>
<h3 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><h1 id="五、InndoDB锁机制"><a href="#五、InndoDB锁机制" class="headerlink" title="五、InndoDB锁机制"></a>五、InndoDB锁机制</h1><p>InnoDB存储引擎当中，参数autocommit=true，自动提交为true，意味着每一条sql就是一个单独的事物。显示开启需要指定begin/start transaction，显示提交commit。  </p>
<h3 id="InnoDB行锁如何实现"><a href="#InnoDB行锁如何实现" class="headerlink" title="InnoDB行锁如何实现"></a>InnoDB行锁如何实现</h3><ol>
<li>通过给索引上的索引项加锁实现的。</li>
<li>通过索引进行数据检索，InnoDB才会使用行级锁，否则使用表锁（锁住索引的所有记录）。</li>
</ol>
<h1 id="六、行锁算法"><a href="#六、行锁算法" class="headerlink" title="六、行锁算法"></a>六、行锁算法</h1><h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>当sql执行按照索引进行数据检索时，查询条件为范围查找（between and、&lt;、&gt;等）且有数据命中时，该sql语句加上的行锁为next-key locks。具体实现：锁住命中区间+下一个区间（左开右闭）</p>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>当sql执行按照索引进行数据检索时，且查询条件的数据不存在时，这是sql语句加上的锁即为Gap locks。具体实现：锁住数据不存在的区间（左开右开）。这也就说明了，记录不存在临键锁退化为间隙锁。</p>
<h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>唯一性索引（主键索引、唯一键索引），条件为精准命中，退化为记录锁（Record lock）。</p>
<h3 id="为什么InnoDB可重复读能解决幻读问题？"><a href="#为什么InnoDB可重复读能解决幻读问题？" class="headerlink" title="为什么InnoDB可重复读能解决幻读问题？"></a>为什么InnoDB可重复读能解决幻读问题？</h3><ol>
<li>临键锁机制。如上文提到，临键锁有效的锁住了相应的区间 ，避免的不同事物之间对数据的影响。</li>
<li>MVCC机制。多版本并发控制，通过版本号等概念，实现了不同事物不同版本的逻辑视图。详细可见<a href="http://zhaoyansheng.top/2019/04/16/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8AMVCC/#more" target="_blank" rel="noopener">MySQL事物隔离级别以及MVCC</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper学习笔记—ZooKeeper概念</title>
    <url>/2019/10/13/ZooKeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、ZooKeeper是什么"><a href="#一、ZooKeeper是什么" class="headerlink" title="一、ZooKeeper是什么"></a>一、ZooKeeper是什么</h2><p>ZooKeeper是一个分布式的、开放源码的分布式应用程序协调服务，是Google的Chubby一个开源实现。它是一个为分布式应用提供一致性服务的软件，提供了配置维护、域名服务、分布式锁、负载均衡、服务注册和发现等功能。</p>
<h2 id="二、ZooKeeper的特性"><a href="#二、ZooKeeper的特性" class="headerlink" title="二、ZooKeeper的特性"></a>二、ZooKeeper的特性</h2><ol>
<li>顺序一致性，从同一个客户端发起的事物请求，最终将会严格按照发起顺序被应用到ZooKeeper中。</li>
<li>原子性，所有事物请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事物，要么都没有应用。</li>
<li>单一视图，无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</li>
<li>可靠性，一旦服务端成功应用了一个事物，并完成对客户端的响应，那么该事物所引起的服务端状态变更将会一致被保留，除非有另一个事物对其进行了变更。</li>
<li>实时性，ZooKeeper保证在一定的时间段内，客户端最终一定能从服务端上读取到最新的数据状态。  </li>
</ol>
<h2 id="三、ZooKeeper概念"><a href="#三、ZooKeeper概念" class="headerlink" title="三、ZooKeeper概念"></a>三、ZooKeeper概念</h2><h3 id="3-1，数据节点Znode"><a href="#3-1，数据节点Znode" class="headerlink" title="3.1，数据节点Znode"></a>3.1，数据节点Znode</h3><p>ZooKeeper中的数据以一定的数据模型存储：整体数据以树形式具有层级关系，类似文件系统的数据模型。图示如下：<br><img src="/2019/10/13/ZooKeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/zk0.png" alt="znode">    </p>
<h4 id="3-1-1，节点类型"><a href="#3-1-1，节点类型" class="headerlink" title="3.1.1，节点类型"></a>3.1.1，节点类型</h4><p>ZK目录树中每个节点对应一个Znode。根据存活时间可以分为持久节点和临时节点。节点的类型在创建时就被确定下来，并且不能改变。持久节点的存活时间不依赖客户端会话，只有客户端在显式执行删除节点操作时，节点才会消失；临时节点的存活时间依赖于客户端会话，当会话结束，临时节点将会被自动删除（也可以手动删除）。利用临时节点的特性，我们可以用来进行集群管理，服务发现等。<br>临时节点不能拥有子节点，持久节点可以有子节点。<br>ZK还提供了顺序节点的节点类型。创建顺序节点时，ZK都会在路径后面自动添加10位数字（计数器），例如,<path></path>0000000001,<path></path>0000000002,……这个计数器可以保证在同一父节点下是唯一的。在ZK内部使用了4个字节的有符号整形来表示这个计数器。</p>
<h4 id="3-1-2，节点数据"><a href="#3-1-2，节点数据" class="headerlink" title="3.1.2，节点数据"></a>3.1.2，节点数据</h4><p>创建节点的时候可以制定节点中存储的数据。ZK保证读和写都是原子操作，且每次读写操作都是对数据的完整读取或完整写入，并不提供对数据进行部分读取或者写入操作。以下命令创建一个节点/test/app，且其存储的数据为app。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create &#x2F;test&#x2F;app app</span></pre></td></tr></table></figure>
<p>ZK虽然可以在节点存储数据，但是其定位并不是一个通用的数据库，不应该在节点存储过多的数据。ZK规定节点的数据大小不能超过1M。</p>
<h4 id="3-1-3，节点属性"><a href="#3-1-3，节点属性" class="headerlink" title="3.1.3，节点属性"></a>3.1.3，节点属性</h4><p>每个Znode维护着各自一系列属性，通过get可以获得节点的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#x2F;test&#x2F;app</span></pre></td></tr><tr><td class="code"><pre><span class="line">app</span></pre></td></tr><tr><td class="code"><pre><span class="line">cZxid &#x3D; 0x20000000e</span></pre></td></tr><tr><td class="code"><pre><span class="line">ctime &#x3D; Thu Jun 30 20:41:55 HKT 2019</span></pre></td></tr><tr><td class="code"><pre><span class="line">mZxid &#x3D; 0x20000000e</span></pre></td></tr><tr><td class="code"><pre><span class="line">mtime &#x3D; Thu Jun 30 20:41:55 HKT 2019</span></pre></td></tr><tr><td class="code"><pre><span class="line">pZxid &#x3D; 0x20000000e</span></pre></td></tr><tr><td class="code"><pre><span class="line">cversion &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataVersion &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">aclVersion &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">ephemeralOwner &#x3D; 0x0</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataLength &#x3D; 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">numChildren &#x3D; 0</span></pre></td></tr></table></figure>
<h5 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h5><p>对于每个Znode来讲，均存在三个版本号：</p>
<ul>
<li>dataVersion，数据版本号，每次对节点进行set操作其值都会增加1（即使设置的相同数据）</li>
<li>cversion，子节点版本号，当znode的子节点有变化时，cversion的值就会增加1</li>
<li>aclVersion，ACL的版本号，关于Znode的ACL（Access Control List，访问控制）</li>
</ul>
<h5 id="事物ID"><a href="#事物ID" class="headerlink" title="事物ID"></a>事物ID</h5><p>对于ZK来讲，每次变化都会产生一个唯一的事物ID，zid（ZooKeeper Transaction Id）。通过zxid可以确定更新操作的先后顺序。zxid1小于zxid2，说明zxid1操作先于zxid2发生。zxid对于整个ZooKeeper都是唯一的，即使操作的是不同的Znode。</p>
<ul>
<li>cZid，Znode创建的事物id</li>
<li>mZid，Znode被修改的事物id，即每次对znode的修改都会更新mZxid。</li>
</ul>
<h5 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h5><p>包括Znode的创建时间和修改时间。</p>
<ul>
<li>ctime，Znode的创建时间，创建后不会改变</li>
<li>mtime，Znode的修改时间，每次更新znode时都会发生变化</li>
</ul>
<h3 id="3-2，ZooKeeper集群"><a href="#3-2，ZooKeeper集群" class="headerlink" title="3.2，ZooKeeper集群"></a>3.2，ZooKeeper集群</h3><p>ZooKeeper是一个由多个server组成的集群，一个leader，多个follower。leader为客户端服务器提供读写服务，除了leader外其他的机器只能提供读服务。</p>
<h4 id="3-2-1，集群角色——leader"><a href="#3-2-1，集群角色——leader" class="headerlink" title="3.2.1，集群角色——leader"></a>3.2.1，集群角色——leader</h4><p>leader是整个ZK集群工作机制的核心，作为整个ZK集群的主节点，负责响应所有对ZK状态变更的请求。主要工作：</p>
<ul>
<li>事物请求的唯一调度和处理，保障集群处理事物的顺序性。</li>
<li>集群内各服务器的调度者。</li>
</ul>
<h4 id="3-2-2，集群角色——Follower"><a href="#3-2-2，集群角色——Follower" class="headerlink" title="3.2.2，集群角色——Follower"></a>3.2.2，集群角色——Follower</h4><p>Follower是ZooKeeper集群状态的跟随者。主要工作：</p>
<ul>
<li>响应本服务器上的读请求</li>
<li>处理leader提议，在leader提交该提议时在本地进行提交</li>
<li>参与新leader的选举</li>
</ul>
<h4 id="3-2-3，集群角色——Observer"><a href="#3-2-3，集群角色——Observer" class="headerlink" title="3.2.3，集群角色——Observer"></a>3.2.3，集群角色——Observer</h4><p>Observer作为观察者角色，在ZK集群读取负载很高或者客户端多到跨机房时，可以用来提高读取的吞吐量。Observer与Follower类似，也有一些区别：</p>
<ul>
<li>不参与leader选举</li>
<li>不响应提议</li>
<li>不参与写操作“过半写成功”策略</li>
<li>不需要将事物持久化到磁盘，observer被重启后需要从leader同步整个名字空间</li>
</ul>
<h3 id="3-3，会话（Session）"><a href="#3-3，会话（Session）" class="headerlink" title="3.3，会话（Session）"></a>3.3，会话（Session）</h3><p>Session指的是ZooKeeper服务器与客户端会话。在ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper会话的一个重要标识，许多与会话相关的运行机制都是基于这个sessionID的，因此，无论是哪台服务器为客户端分配的sessionID，都务必保证全局唯一。</p>
<h4 id="3-3-1，会话（Session）"><a href="#3-3-1，会话（Session）" class="headerlink" title="3.3.1，会话（Session）"></a>3.3.1，会话（Session）</h4><p>在Zookeeper客户端与服务端成功完成连接创建后，就创建了一个会话，Zookeeper会话在整个运行期间的生命周期中，会在不同的会话状态中之间进行切换，这些状态可以分为CONNECTING、CONNECTED、RECONNECTING、RECONNECTED、CLOSE等。一旦客户端开始创建Zookeeper对象，那么客户端状态就会变成CONNECTING状态，同时客户端开始尝试连接服务端，连接成功后，客户端状态变为CONNECTED，通常情况下，由于断网或其他原因，客户端与服务端之间会出现断开情况，一旦碰到这种情况，Zookeeper客户端会自动进行重连服务，同时客户端状态再次变成CONNCTING，直到重新连上服务端后，状态又变为CONNECTED，在通常情况下，客户端的状态总是介于CONNECTING 和CONNECTED之间。但是，如果出现诸如会话超时、权限检查或是客户端主动退出程序等情况，客户端的状态就会直接变更为CLOSE状态。</p>
<h4 id="3-3-2，会话创建"><a href="#3-3-2，会话创建" class="headerlink" title="3.3.2，会话创建"></a>3.3.2，会话创建</h4><p>Session是Zookeeper中的会话实体，代表了一个客户端会话，其包含了如下四个属性：</p>
<ol>
<li>sessionID。会话ID，唯一标识一个会话，每次客户端创建新的会话时，Zookeeper都会为其分配一个全局唯一的sessionID。</li>
<li>TimeOut。会话超时时间，客户端在构造Zookeeper实例时，会配置sessionTimeout参数用于指定会话的超时时间，Zookeeper客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间。</li>
<li>TickTime。下次会话超时时间点，为了便于Zookeeper对会话实行”分桶策略”管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上TimeOut。</li>
<li>isClosing。标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的isClosing标记为”已关闭”，这样就能确保不再处理来自该会话的新请求了。  </li>
</ol>
<p>Zookeeper为了保证请求会话的全局唯一性，在SessionTracker初始化时，调用initializeNextSession方法生成一个sessionID，之后在Zookeeper运行过程中，会在该sessionID的基础上为每个会话进行分配。  </p>
<h4 id="3-3-3，会话管理"><a href="#3-3-3，会话管理" class="headerlink" title="3.3.3，会话管理"></a>3.3.3，会话管理</h4><p>Zookeeper的会话管理主要是通过SessionTracker来负责，其采用了分桶策略（将类似的会话放在同一区块中进行管理）进行管理，以便Zookeeper对会话进行不同区块的隔离处理以及同一区块的统一处理。</p>
<h3 id="3-4，watcher事件监听"><a href="#3-4，watcher事件监听" class="headerlink" title="3.4，watcher事件监听"></a>3.4，watcher事件监听</h3><p>ZooKeeper允许用户在指定节点上注册一些Watcher，当数据节点发生变化的时候，ZooKeeper服务器会把这个变化的通知发送给感兴趣的客户端。总体可以分为三个过程：客户端注册watcher，服务器处理watcher、客户端回调watcher处理。<br>watcher有几个特性：</p>
<ul>
<li>一次性。watcher被触发后，ZooKeeper会将其从响应的存储中移除。因此在watcher的使用上，需要反复注册。这样能有效减轻服务端的压力。</li>
<li>客户端串行执行。客户端回调的过程是一个串行同步的过程，这为我们保证了顺序。不能因为一个watcher的处理逻辑影响了整个客户端的watcher回调。</li>
<li>轻量。WatcherEvent是ZooKeeper整个Watcher通知机制最小的通知单元，整个数据结构包含三部分内容：通知状态、事件类型和节点路径。也就是ZK只会告诉客户端指定节点变更，具体变更需要客户端主动拉取一次。  </li>
</ul>
<h2 id="四、ZooKeeper用途"><a href="#四、ZooKeeper用途" class="headerlink" title="四、ZooKeeper用途"></a>四、ZooKeeper用途</h2><h3 id="4-1，分布式服务注册与订阅"><a href="#4-1，分布式服务注册与订阅" class="headerlink" title="4.1，分布式服务注册与订阅"></a>4.1，分布式服务注册与订阅</h3><p>在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，代表：dubbo。</p>
<h3 id="4-2，分布式配置中心"><a href="#4-2，分布式配置中心" class="headerlink" title="4.2，分布式配置中心"></a>4.2，分布式配置中心</h3><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。代表：百度的disconf。</p>
<h3 id="4-3，命名服务"><a href="#4-3，命名服务" class="headerlink" title="4.3，命名服务"></a>4.3，命名服务</h3><p>在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，进程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</p>
<h3 id="4-4，分布式锁"><a href="#4-4，分布式锁" class="headerlink" title="4.4，分布式锁"></a>4.4，分布式锁</h3><p>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock已绊预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
<h3 id="4-5，负载均衡"><a href="#4-5，负载均衡" class="headerlink" title="4.5，负载均衡"></a>4.5，负载均衡</h3><h3 id="4-6，master选举"><a href="#4-6，master选举" class="headerlink" title="4.6，master选举"></a>4.6，master选举</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明手册——探索隐藏目录.git</title>
    <url>/2019/05/26/Git%E6%89%8B%E5%86%8C%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h3><p>使用Git作为一个版本库，管理代码版本信息和历史记录。在一个工作区当中，我们可以通过ctrl+z、ctrl+y完成内存历史版本的更替，git是如何做到分支管理、版本管理的呢？这就涉及到了git工作空间里隐藏的.git目录，git通过这个隐藏目录实现了分支、版本的状态记录以及切换。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在介绍git如何做到分支切换、版本管理之前，首先要介绍下git对象相关的概念。对象库是Git版本库实现的核心。它包含原始数据文件和所有日志消息、作者信息、日期、以及其他用来重建项目任意版本或分支的信息。Git放在对象库里的对象只有4种类型：块(blob)、目录树(tree)、提交(commit)和标签(tag)。就是由这4种对象构成Git高层数据结构的基础。</p>
<h4 id="块-blob"><a href="#块-blob" class="headerlink" title="块 - blob"></a>块 - blob</h4><p>文件的每一个版本表示为一个块(blob)。一个blob保存一个文件的数据，但不包含任何关于这个文件的元数据，甚至连文件名也没有。</p>
<h4 id="目录树-tree"><a href="#目录树-tree" class="headerlink" title="目录树 - tree"></a>目录树 - tree</h4><p>一个目录树对象代表一层目录信息，它记录blob标识符、路径名和在一个目录里所有文件的一些元数据。</p>
<h4 id="提交-commit"><a href="#提交-commit" class="headerlink" title="提交 - commit"></a>提交 - commit</h4><p>一个提交对象保存版本库中一次变化的元数据，包括作者、提交者、提交日期和日志消息。每一个提交对象指向一个目录树对象，而这个目录树对象在一张完整的快照中捕获提交时版本的状态。</p>
<h4 id="标签-tag"><a href="#标签-tag" class="headerlink" title="标签 - tag"></a>标签 - tag</h4><p>一个标签对象分配一个任意的且人类可读的名字给一个特定对象，通常是一个提交对象。</p>
<h3 id="操作-git目录"><a href="#操作-git目录" class="headerlink" title="操作.git目录"></a>操作.git目录</h3><h4 id="git目录介绍"><a href="#git目录介绍" class="headerlink" title=".git目录介绍"></a>.git目录介绍</h4><p>新建一个目录作为git仓库，通过<strong>git init</strong>初始化git仓库。可以看到当前版本库里面是有.git目录，里面包含HEAD，config，description和branches、hooks、info、objects、refs五个文件夹。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ mkdir gittest</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ cd gittest\</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git init</span></pre></td></tr><tr><td class="code"><pre><span class="line">Initialized empty Git repository in D:/gittest/.git/</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ ls -al</span></pre></td></tr><tr><td class="code"><pre><span class="line">total <span class="number">12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span> <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> ./</span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span> <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> ../</span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span> <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> .git/</span></pre></td></tr></table></figure>
<p>进入.git目录可以看到里面这个隐藏目录里面控制版本以及各类元属性信息，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">λ cd .git\</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ ls -al</span></pre></td></tr><tr><td class="code"><pre><span class="line">total <span class="number">11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span>   <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> ./</span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span>   <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> ../</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span>  <span class="number">23</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span> <span class="number">157</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> config</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span>  <span class="number">73</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> description</span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span>   <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> hooks/</span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span>   <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> info/</span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span>   <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> objects/</span></pre></td></tr><tr><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> zys <span class="number">197609</span>   <span class="number">0</span> May <span class="number">26</span> <span class="number">16</span>:<span class="number">59</span> refs/</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─hooks</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─info</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─objects</span></pre></td></tr><tr><td class="code"><pre><span class="line">│  ├─info</span></pre></td></tr><tr><td class="code"><pre><span class="line">│  └─pack</span></pre></td></tr><tr><td class="code"><pre><span class="line">└─refs</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├─heads</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └─tags</span></pre></td></tr></table></figure>
<p>1，HEAD文件是当前分支的指向，比如当前分支指向master，则存储了对master的引用。<br>2，config文件存储了一些配置信息，属于配置文件。此处不细细描述。<br>3，hooks/存储了一些钩子脚本，暂时不表。<br>4，info文件夹是全局性排除文件，它和.gitignore是互补的。里面就一个exclude文件。<br>5，objects文件里面存放了所有的数据。<br>6，refs文件存放了提交对象的指针。</p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>HEAD存放了当前分支指向，当我们主动修改HEAD文件的指向，也是相当于切换分支<strong>checkout branch-name</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ cat HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">ref: refs/heads/master</span></pre></td></tr><tr><td class="code"><pre><span class="line">#修改HEAD内容完成切换分支功能</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ echo <span class="string">'ref: refs/heads/develop'</span> &gt; HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (develop -&gt; origin)</span></pre></td></tr></table></figure>
<p>目前objects、refs目录是空的，我们在版本仓库里面添加一个文件并做一次add操作，看下这两个目录的变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ echo <span class="string">"v1"</span> &gt; v1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include in what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">nothing added to commit but untracked files <span class="title">present</span> <span class="params">(use <span class="string">"git add"</span> to track)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">gittest</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git add v1.txt</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\gittest\.<span class="title">git</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ tree</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">├─hooks</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">├─info</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">├─objects</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">│  ├─aa</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">│  ├─info</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">│  └─pack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">└─refs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    ├─heads</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    └─tags</span></span></pre></td></tr></table></figure>
<p>可以看到，objects目录下面多了一个aa的文件夹。在介绍多出来的aa文件夹之前，先介绍git常用的两个命令。1，计算文件的SHA-1校验和<strong>git hash-object filename</strong>；2，查看对象（上文提到）的内容和类型<strong>git cat-file -p/-t filename</strong>。我们看一下刚才新添加的文件的SHA-1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git hash-object v1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">aa67cc0c2694dd2e15ebd35464e04b266b72850c</span></pre></td></tr></table></figure>
<p>刚才我们创建的v1.txt文件的SHA-1为aa开头的67c…，开头与objects新增的文件夹名相同。进入到新增的文件夹看下文件目录，看到文件夹下有67cc0c2694dd2e15ebd35464e04b266b72850c的文件。这个文件和上一级文件夹组成了新增文件的SHA-1的值。这就说明了，当我们add一个文件到暂存区的时候，git会创建一个对应的objects，两级目录，前两位作为objects下面的一级目录，后面的数值作为二级文件名。通过<strong>cat-file</strong>可以查看文件的类型和内容。可以看到，aa67cc0c是一个blob块类型，指向了本次添加到暂存区的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest\.git\objects (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ cd aa</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git\objects\aa (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ ls</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">67</span>cc0c2694dd2e15ebd35464e04b266b72850c</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git\objects\aa (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -t aa67cc0c</span></pre></td></tr><tr><td class="code"><pre><span class="line">blob</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git\objects\aa (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -p aa67cc0c</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"v1"</span></span></pre></td></tr></table></figure>
<p>当我们将暂存区新增的这个文件添加到本地版本库时，可以观察到.git目录又有了新的变化。发现新增了两个文件夹。 使用<strong>git log –pretty=oneline</strong>可以查看提交的commit-id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git commit -m <span class="string">'addv1'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[master (root-commit) <span class="number">3</span>ed76ec] <span class="string">'addv1'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> v1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ cd .git\</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ ls</span></pre></td></tr><tr><td class="code"><pre><span class="line">COMMIT_EDITMSG  HEAD  config  description  hooks/  index  info/  logs/  objects/  refs/</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─hooks</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─info</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─logs</span></pre></td></tr><tr><td class="code"><pre><span class="line">│  └─refs</span></pre></td></tr><tr><td class="code"><pre><span class="line">│      └─heads</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─objects</span></pre></td></tr><tr><td class="code"><pre><span class="line">│  ├─<span class="number">09</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">│  ├─<span class="number">3</span>e</span></pre></td></tr><tr><td class="code"><pre><span class="line">│  ├─aa</span></pre></td></tr><tr><td class="code"><pre><span class="line">│  ├─info</span></pre></td></tr><tr><td class="code"><pre><span class="line">│  └─pack</span></pre></td></tr><tr><td class="code"><pre><span class="line">└─refs</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├─heads</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └─tags</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>ed76ec5a633c13942cdc205d8e82a83214ed4b5 <span class="string">'addv1'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -t <span class="number">3</span>ed76e</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -p <span class="number">3</span>ed76e</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree <span class="number">09</span>cd1fcab91850c07c5ef1f641652182eba9816d</span></pre></td></tr><tr><td class="code"><pre><span class="line">author VfEver &lt;<span class="number">13146770925</span>@<span class="number">126</span>.com&gt; <span class="number">1558878862</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">committer VfEver &lt;<span class="number">13146770925</span>@<span class="number">126</span>.com&gt; <span class="number">1558878862</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'addv1'</span></span></pre></td></tr></table></figure>
<p>可以看到，刚才我们提交产生的objects（commmit-id 3ed76e）是一个commmit类型，这个commit类型的内容为我们提交的信息，包括作者信息、注释信息等。里面还有一个tree类型的对象。继续展开这个tree对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -t <span class="number">09</span>cd1fcab</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest\.git (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -p <span class="number">09</span>cd1fcab</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob aa67cc0c2694dd2e15ebd35464e04b266b72850c    v1.txt</span></pre></td></tr></table></figure>
<p>可以看到最终tree类型对象内容为指向blob的指针，继续展开就是我们上文添加的文件内容。此时我们查看refs/heads中当前分支存储的内容，就会发现heads里面存储的就是当前分支指向的commit-id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest\.git\refs\heads (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ cat master</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>ed76ec5a633c13942cdc205d8e82a83214ed4b5</span></pre></td></tr></table></figure>
<p>再联系下上文我们提到的git中关键的各类对象，blob块对象存储了文件的数据，commit提交对象存储了当前提交的元数据信息（提交者、注释等），tree树对象则记录blob的标识符路径名等文件的元数据信息。我们继续做一次commit就可以看到tree相关的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ echo <span class="string">"v2"</span> &gt; v2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git add v2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git commit -m <span class="string">'addv2'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[master ca52c36] <span class="string">'addv2'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> v2.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">ca52c3650a62d799aaa3b5608d037105fb1568c7 <span class="string">'addv2'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>ed76ec5a633c13942cdc205d8e82a83214ed4b5 <span class="string">'addv1'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -p ca52c36</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree c2f43b16b1e7591fbeed8422c61cadab2aeb77ed</span></pre></td></tr><tr><td class="code"><pre><span class="line">parent <span class="number">3</span>ed76ec5a633c13942cdc205d8e82a83214ed4b5</span></pre></td></tr><tr><td class="code"><pre><span class="line">author VfEver &lt;<span class="number">13146770925</span>@<span class="number">126</span>.com&gt; <span class="number">1558881909</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">committer VfEver &lt;<span class="number">13146770925</span>@<span class="number">126</span>.com&gt; <span class="number">1558881909</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'addv2'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -t c2f43b16b</span></pre></td></tr><tr><td class="code"><pre><span class="line">tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\gittest (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git cat-file -p c2f43b16b</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob aa67cc0c2694dd2e15ebd35464e04b266b72850c    v1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">100644</span> blob e08f1c7873bf3e22bef69f6bc96d6fc6bc5b617d    v2.txt</span></pre></td></tr></table></figure>
<p>通过看第二次commit-id的内容信息，可以发现有一个parent，指向我们的第一次提交，也就是上一次提交。第一次提交的时候，是没有这个parent指针的。继续查看这次新产生的tree对象的内容，则记录了两条blob对象，一条第一次add v1的blob块对象，一条第二次add v2的blob块对象。也就是tree树对象仅仅存储了块对象的元属性信息。<br>如此，我们可以了解到git在add、commit的时候，产生的数据信息如下：<br><img src="/2019/05/26/Git%E6%89%8B%E5%86%8C%EF%BC%88%E5%85%AD%EF%BC%89/dotgit.PNG" alt="git操作结果">  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明手册——Git rebase使用</title>
    <url>/2019/05/11/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h3 id="reabse介绍"><a href="#reabse介绍" class="headerlink" title="reabse介绍"></a>reabse介绍</h3><p>我们在使用git提交远程仓库，或者同步远程仓库代码到本地仓库，查看提交记录的时候，提交历史往往是一条分叉的树，这在多人协作开发的过程中是十分常见的。有没有办法使我们的提交干净整洁？提交记录更加简洁一点？这时候rebase派上用场。<strong>git rebase</strong> 有三个作用：1，合并多个commmit为一个完整的commit；2，将提交记录整洁干净；3，将某一段commit合并到另一个分支。接下来将详细介绍这三个作用的使用场景和用法。  </p>
<h3 id="rebase作用"><a href="#rebase作用" class="headerlink" title="rebase作用"></a>rebase作用</h3><h4 id="合并多个commit为一个完整的commit"><a href="#合并多个commit为一个完整的commit" class="headerlink" title="合并多个commit为一个完整的commit"></a>合并多个commit为一个完整的commit</h4><p>1.首先查看工作区状态，确保工作区、暂存区、版本库已经远程仓库一致。然后我们做一些普通的<strong>add</strong> 和<strong>commit</strong> 操作。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git status      ##查看当前状态</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">nothing to commit, working directory clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ touch a.go      ##创建一个新文件a.go，添加到暂存区并提交到本地版本库</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include in what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a.go</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">nothing added to commit but untracked files <span class="title">present</span> <span class="params">(use <span class="string">"git add"</span> to track)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git add a.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git commit -m 'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">[master ed0e588] 'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"> 1 file changed, 0 <span class="title">insertions</span><span class="params">(+)</span>, 0 <span class="title">deletions</span><span class="params">(-)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"> create mode 100644 a.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ touch b.go    ##创建一个新文件b.go，添加到暂存区并提交到本地版本库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git add b.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git commit -m 'add-b.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">[master 2c0c671] 'add-b.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"> 1 file changed, 0 <span class="title">insertions</span><span class="params">(+)</span>, 0 <span class="title">deletions</span><span class="params">(-)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"> create mode 100644 b.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ vim a.go    ##修改a.go文件的内容，添加到暂存区并提交到本地版本库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git status</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">On branch master</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Changes not staged <span class="keyword">for</span> commit:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="params">(use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="params">(use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes in working directory)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">        modified:   a.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">no changes added to <span class="title">commit</span> <span class="params">(use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git add a.go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">rushgit</span> <span class="params">(master -&gt; origin)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">λ git commit -m 'modify-a.go'</span></span></pre></td></tr></table></figure>
<p>这时候图形化方式查看一下git的提交历史记录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">λ git log --graph --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">*<span class="number">409</span>c288f44bcbcbcb3f2a9a91ac00b7967a2ec91 <span class="string">'modify-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">*<span class="number">2</span>c0c671f35f238a1367eea8681bcdcad82b4ba1d <span class="string">'add-b.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">*ed0e58875017a20e4c165f5e6746fe939a6f7ac7 <span class="string">'add-a.go'</span></span></pre></td></tr></table></figure>
<p>可以看到本地版本库有三条提交记录，分别对应我们的三次提交。这三次的更改就是添加了a.go，b.go，并修改了a.go。当我们向远程关联分支提交的时候，可不可以合并成一个commit呢？就是通过rebase功能。  </p>
<p>2.使用<strong>git rebase</strong> 合并多个commit为一个commit，使本地版本仓库的提交记录简洁，提交到远程也更清晰。<br>命令为git rebase -i [start commit-id] [end commit-id]。start commit-id和end commit-id按照字面意思就是开始id和结束id，也就是你想合并哪一段区间的提交。这个区间是前开后闭的，也就是如果你想合并3个commit的提交，那么start commit-id需要设置为倒数第四个commit-id。此处我们应该设置为<strong>bdc2c7a88</strong> 。    </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">λ git rebase -i bdc2c7a88</span></pre></td></tr><tr><td class="code"><pre><span class="line">pick ed0e588 <span class="string">'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pick <span class="number">2</span>c0c671 <span class="string">'add-b.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pick <span class="number">409</span>c288 <span class="string">'modify-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Rebase bdc2c7a..409c288 onto bdc2c7a (3 command(s))</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Commands:</span></pre></td></tr><tr><td class="code"><pre><span class="line"># p, pick = use commit</span></pre></td></tr><tr><td class="code"><pre><span class="line"># r, reword = use commit, but edit the commit message</span></pre></td></tr><tr><td class="code"><pre><span class="line"># e, edit = use commit, but stop for amending</span></pre></td></tr><tr><td class="code"><pre><span class="line"># s, squash = use commit, but meld into previous commit</span></pre></td></tr><tr><td class="code"><pre><span class="line"># f, fixup = like "squash", but discard this commits log message</span></pre></td></tr><tr><td class="code"><pre><span class="line"># x, exec = run command (the rest of the line) using shell</span></pre></td></tr><tr><td class="code"><pre><span class="line"># d, drop = remove commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># However, if you remove everything, the rebase will be aborted.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Note that empty commits are commented out</span></pre></td></tr></table></figure>
<p>此时可以看到git给出了此次rebase的操作提示，在此给一下相关命令的解释：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，p（pick）保留此commit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>，r（reword）保留此commit但是需要修改commit的注释</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>，e（edit）保留该commit, 但要停下来修改该提交(不仅仅修改注释)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>，s（squash）将该commit和前一个commit合并</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">5</span>，f（fixup）：将该commit和前一个commit合并，但不要保留该提交的注释信息</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span>，e（exec）：执行shell命令</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span>，d（drop）：要丢弃该commit（缩写:d）</span></pre></td></tr></table></figure>
<p>此时如果我们只保留最后一个commit（409c28），其他两个commit直接和前一个commit合并，但是同时保留注释信息。这时候就修改命令行如下：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p ed0e588 <span class="string">'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">s <span class="number">2</span>c0c671 <span class="string">'add-b.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">s 409c288 'modify-a.go'     ##此时出现如下界面，提示我们即将完成的操作，可以继续修改commit相关信息。  </span></pre></td></tr><tr><td class="code"><pre><span class="line">###################################################</span></pre></td></tr><tr><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span></pre></td></tr><tr><td class="code"><pre><span class="line"># The first commits message is:</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># This is the 2nd commit message:</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'add-b.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># This is the 3rd commit message:</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'modify-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span></pre></td></tr><tr><td class="code"><pre><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Date:      Sat May 11 22:58:50 2019 +0800</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># interactive rebase in progress; onto bdc2c7a</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Last commands done (3 commands done):</span></pre></td></tr><tr><td class="code"><pre><span class="line">#    s 2c0c671 'add-b.go'</span></pre></td></tr><tr><td class="code"><pre><span class="line">#    s 409c288 'modify-a.go'</span></pre></td></tr><tr><td class="code"><pre><span class="line"># No commands remaining.</span></pre></td></tr><tr><td class="code"><pre><span class="line"># You are currently editing a commit while rebasing branch 'master' on 'bdc2c7a'.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">#       new file:   a.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">#       new file:   b.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">#</span></pre></td></tr><tr><td class="code"><pre><span class="line">```  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span>.此时可以看到rebase的效果如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line">![git-rebase结果](Git手册（五）/git-result.PNG)  </span></pre></td></tr><tr><td class="code"><pre><span class="line">使用git log查看结果如下(reabase操作会生成一个新的commit-id来完成合并)：  </span></pre></td></tr><tr><td class="code"><pre><span class="line">```java</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git log</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cf0a58d24cbf09973645baaab039177bd857328d</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: VfEver &lt;<span class="number">13146770925</span>@<span class="number">126</span>.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sat May <span class="number">11</span> <span class="number">22</span>:<span class="number">58</span>:<span class="number">50</span> <span class="number">2019</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'add-b.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'modify-a.go'</span></span></pre></td></tr></table></figure>
<h4 id="简洁的提交记录，去除分叉"><a href="#简洁的提交记录，去除分叉" class="headerlink" title="简洁的提交记录，去除分叉"></a>简洁的提交记录，去除分叉</h4><p>1.从当前分支新拉出来一个分支，取名为develop，然后从此分支做一个commit，然后在master分支做一个commit并提交。此时develop分支和远程master分支就有了分叉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">nothing to commit, working directory clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git checkout -b develop</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">'develop'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ touch c.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git add c.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git commit -m <span class="string">'add-g.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[develop <span class="number">861</span>b393] <span class="string">'add-g.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c.go</span></pre></td></tr><tr><td class="code"><pre><span class="line"> D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git checkout master  ##在此做一个add、commit、push（add commit省略）</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Switched to branch <span class="string">'master'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git push</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">6</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), <span class="number">599</span> bytes | <span class="number">0</span> bytes/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">6</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Resolving deltas: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">To git<span class="meta">@github</span>.com:VfEver/rushgit.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   bdc2c7a..fc6eb4b  master -&gt; master</span></pre></td></tr><tr><td class="code"><pre><span class="line">```  </span></pre></td></tr><tr><td class="code"><pre><span class="line">![git-rebase](Git手册（五）/git_rebase_1.PNG)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span>.此时如果我们在develop分支pull一下，将远程分支的提交同步到本地develop分支：</span></pre></td></tr><tr><td class="code"><pre><span class="line">```java</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git pull origin master</span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * branch            master     -&gt; FETCH_HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> e.go | <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> e.go</span></pre></td></tr></table></figure>
<p>此时的pull操作还会产生一个commit-id，现在的分支树用图形表示如下：<br><img src="/2019/05/11/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%94%EF%BC%89/git_rebase_2.PNG" alt="git-rebase"><br>可以看到develop和远程master合并之后，产生了一个新的commit-id（ca8fe16），同时合并了远程的仓库提交历史，并产生了分叉。此时本地develop分支结果如下：<br><img src="/2019/05/11/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%94%EF%BC%89/git_rebase_3.PNG" alt="git-rebase"><br>3.如何解决这个分叉？就是接下来rebase的操作，我们先将本地develop分支回滚到上一个版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git reset --hard <span class="number">861</span>b3</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now at <span class="number">861</span>b393 <span class="string">'add-g.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git log</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit <span class="number">861</span>b39322ed33744365bd322b8dcd26c7d5d859c</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: VfEver &lt;<span class="number">13146770925</span>@<span class="number">126</span>.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Sun May <span class="number">12</span> <span class="number">09</span>:<span class="number">25</span>:<span class="number">23</span> <span class="number">2019</span> +<span class="number">0800</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'add-g.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit cf0a58d24cbf09973645baaab039177bd857328d</span></pre></td></tr></table></figure>
<p>此时我们进行rebase操作，将master分支合并到本地develop分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">λ git rebase fc6eb4b1</span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head to replay your work on top of it...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: <span class="string">'add-g.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">f5c7f65eacd5f7f93747698d436f8c764ec4e916 <span class="string">'add-g.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fc6eb4b1ca7530aa39fcd3a3872317b7d715e703 <span class="string">'add-e.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cf0a58d24cbf09973645baaab039177bd857328d <span class="string">'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">bdc2c7a88bbd7d4b4fa41bc0b61576b79f8e8efa <span class="string">'modify-lww.txt'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7f</span>985260c0b40d9f6db8f251bc067abf69121f37 <span class="string">'add'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f5da69a6bdf6a44d75f7b4088b2d26d59abe497f add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb52623011006575566736bc0c387107dae5c6 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3125251</span>a15943118724f9dce6302c7351444880e Update README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9e7674</span>cbd635f8e52e2434113e05479bf7281b9d Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">68</span>c86da5dc6372755fe7048847aed6cd9b8f001f add java9</span></pre></td></tr></table></figure>
<p>此时的develop分支提交树则变成了如下（一条干净整洁的直线）：<br><img src="/2019/05/11/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%94%EF%BC%89/git_rebase_4.PNG" alt="git-rebase"></p>
<h4 id="将某一段commit合并到另一个分支"><a href="#将某一段commit合并到另一个分支" class="headerlink" title="将某一段commit合并到另一个分支"></a>将某一段commit合并到另一个分支</h4><p><img src="/2019/05/11/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%94%EF%BC%89/git_rebase_5.PNG" alt="git-rebase"><br>如图我想将处于develop分支的C5到C6的提交粘贴至master分支，这个时候通过rebase功能也可以达到这个效果。<br>1.checkout develop分支，在develop分支做三次commit（C4、C5、C6）。之后在master分支做一个C3的commit。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ touch z.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git add z.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git commit -m <span class="string">'add-z.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[develop <span class="number">16</span>c1602] <span class="string">'add-z.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> z.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ touch x.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git add x.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git commit -m <span class="string">'add-x.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[develop <span class="number">298</span>bf3a] <span class="string">'add-x.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> x.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ touch c.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git add c.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git commit -m <span class="string">'add-c.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[develop <span class="number">5</span>d2f6c0] <span class="string">'add-c.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> c.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git checkout master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'master'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ touch v.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git add v.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git commit -m <span class="string">'add-v.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[master <span class="number">7978153</span>] <span class="string">'add-v.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> v.sh</span></pre></td></tr></table></figure>
<p>2.此时在master分支，将develop分支的C5-C6的提交粘贴至当前分支，就是使用<strong>git rebase [start commit-id] [end commit-id]  –onto  [branchName]</strong> 。同上，这个起止点也是一个左开右闭区间，所以起点要前进一个，也就是git rebase C4 C6 –onto master。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\rushgit (develop -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git rebase <span class="number">16</span>c1602 <span class="number">5</span>d2f6c --onto master</span></pre></td></tr><tr><td class="code"><pre><span class="line">First, rewinding head to replay your work on top of it...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: <span class="string">'add-x.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Applying: <span class="string">'add-c.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">D:\rushgit (HEAD detached at <span class="number">4</span>ebf303 -&gt; origin)</span></pre></td></tr></table></figure>
<p>此时HEAD指向了4ebf303（当前的HEAD可以认为是一个游离的HEAD），一个新的commit-id。此时master分支HEAD其实并没有指向当前粘贴过来的现在的commit-id。当我们试图切回master分支的时候，会给我们一个提示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">λ git checkout master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Warning: you are leaving <span class="number">2</span> commits behind, not connected to</span></pre></td></tr><tr><td class="code"><pre><span class="line">any of your branches:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">4</span>ebf303 <span class="string">'add-c.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">57f</span>109c <span class="string">'add-x.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">If you want to keep them by creating a <span class="keyword">new</span> branch, <span class="keyword">this</span> may be a good time</span></pre></td></tr><tr><td class="code"><pre><span class="line">to <span class="keyword">do</span> so with:</span></pre></td></tr><tr><td class="code"><pre><span class="line"> git branch &lt;<span class="keyword">new</span>-branch-name&gt; <span class="number">4</span>ebf303</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'master'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by <span class="number">1</span> commit.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git push"</span> to publish your local commits)</span></pre></td></tr></table></figure>
<p>提示显示，此时正在丢弃两个提交，而且这两个提交并没有关联到任何分支。我们也可以通过命令<strong>git branch <new-branch-name> 4ebf303</new-branch-name></strong>通过新建一个分支完成关联。此时切回master分支，也可以通过<strong>git reset –hard 4ebf303</strong>完成master分支的HEAD指向4ebf303。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\rushgit (master -&gt; origin)</span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git reset --hard  <span class="number">797815</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now at <span class="number">7978153</span> <span class="string">'add-v.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">λ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span>ebf303885c1c4e3a034b4b3fd2ad8ff0debff74 <span class="string">'add-c.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">57f</span>109c8ea5805bfdaee7631eb2575ff71317a49 <span class="string">'add-x.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">79781531517</span>c9f834564f9a43ef213e90cc74156 <span class="string">'add-v.sh'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">584</span>b02b6bc55a76b50f83a466f505ee08ad6d189 <span class="string">'add-w.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fc6eb4b1ca7530aa39fcd3a3872317b7d715e703 <span class="string">'add-e.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cf0a58d24cbf09973645baaab039177bd857328d <span class="string">'add-a.go'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">bdc2c7a88bbd7d4b4fa41bc0b61576b79f8e8efa <span class="string">'modify-lww.txt'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7f</span>985260c0b40d9f6db8f251bc067abf69121f37 <span class="string">'add'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">f5da69a6bdf6a44d75f7b4088b2d26d59abe497f add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb52623011006575566736bc0c387107dae5c6 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3125251</span>a15943118724f9dce6302c7351444880e Update README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9e7674</span>cbd635f8e52e2434113e05479bf7281b9d Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">68</span>c86da5dc6372755fe7048847aed6cd9b8f001f add java9</span></pre></td></tr></table></figure>
<p>这就完成了C5、C6到master分支C3后的粘贴。如果使用简单的<strong>git rebase [branch-name]</strong>，就是单纯将branch-name的分支上提交的代码复制到当前分支，当前的分支提交在后（也就是作为最新的commit添加在从其他分支粘贴过来的提交之后）。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="https://www.codercto.com/a/43072.html" target="_blank" rel="noopener">https://www.codercto.com/a/43072.html</a></li>
<li><a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">http://gitbook.liuhui998.com/4_2.html</a></li>
<li><a href="https://www.jianshu.com/p/4a8f4af4e803" target="_blank" rel="noopener">https://www.jianshu.com/p/4a8f4af4e803</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离级别以及MVCC</title>
    <url>/2019/04/16/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8AMVCC/</url>
    <content><![CDATA[<h4 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h4><p>前文提到了MySQL的四种隔离级别：  </p>
<ul>
<li>READ UNCOMMITTED（读取未提交）</li>
<li>READ COMMITTED（读取已提交）</li>
<li>REPEATABLE READ（可重复读）</li>
<li>SERIALIZABLE（串行化）<br>接下来将对这些不同的隔离级别分别进行实验，测试不同隔离级别下对事务的影响以及最佳实践。  </li>
</ul>
<h4 id="常用SQL命令"><a href="#常用SQL命令" class="headerlink" title="常用SQL命令"></a>常用SQL命令</h4><p>在进行不同隔离级别实验前，先进行一些常用sql预热准备。<br>查看当前数据库隔离级别sql：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt;select @<span class="meta">@tx</span>_isolation;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+-----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| @<span class="meta">@tx</span>_isolation  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+-----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| REPEATABLE-READ |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+-----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure>
<p>更改当前session的事务隔离级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read committed;#设置隔离级别为读已提交</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.02</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; select @@tx_isolation</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| @<span class="meta">@tx</span>_isolation |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| READ-COMMITTED |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----------------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure>
<h4 id="每种隔离级别对事务的影响"><a href="#每种隔离级别对事务的影响" class="headerlink" title="每种隔离级别对事务的影响"></a>每种隔离级别对事务的影响</h4><p>实验数据库信息：<br>版本：5.7.9-log<br>存储引擎：InnoDB<br>表结构：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table tx_test\G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">*************************** <span class="number">1</span>. row ***************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Table: tx_test</span></pre></td></tr><tr><td class="code"><pre><span class="line">Create Table: CREATE TABLE `tx_test` (</span></pre></td></tr><tr><td class="code"><pre><span class="line">  `id` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  `name` varchar(<span class="number">18</span>) DEFAULT NULL,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; show create table tx_test_1\G</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">*************************** <span class="number">1</span>. row ***************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Table: tx_test_1</span></pre></td></tr><tr><td class="code"><pre><span class="line">Create Table: CREATE TABLE `tx_test_1` (</span></pre></td></tr><tr><td class="code"><pre><span class="line">  `id` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  `value` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT NULL,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span>,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  KEY `value` <span class="params">(`value`)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">) ENGINE</span>=InnoDB DEFAULT CHARSET=utf8</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure>
<p>数据准备：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="function">insert into <span class="title">tx_test</span><span class="params">(`name`)</span> <span class="title">value</span> <span class="params">(<span class="string">'lu'</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt;  insert into <span class="title">tx_test</span><span class="params">(`name`)</span> <span class="title">value</span> <span class="params">(<span class="string">'wen'</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt;  insert into <span class="title">tx_test</span><span class="params">(`name`)</span> <span class="title">value</span> <span class="params">(<span class="string">'wen'</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; insert into <span class="title">tx_test_1</span><span class="params">(`value`)</span> <span class="title">value</span> <span class="params">(<span class="number">1</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt;  insert into <span class="title">tx_test_1</span><span class="params">(`value`)</span> <span class="title">value</span> <span class="params">(<span class="number">3</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; insert into <span class="title">tx_test_1</span><span class="params">(`value`)</span> <span class="title">value</span> <span class="params">(<span class="number">5</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; insert into <span class="title">tx_test_1</span><span class="params">(`value`)</span> <span class="title">value</span> <span class="params">(<span class="number">6</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr></table></figure>
<h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h5><p>在该隔离级别中，事务可以读取其他未提交事务的执行结果。读取未提交的数据，也称之为脏读。实验如下：  </p>
<ol>
<li>设置当前会话隔离级别为未提交读：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启事务，并在当前事务中进行一次查询（id=1）：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; select * from tx_test where id </span>= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | lu   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>打开另一个会话，设置会话隔离级别为未提交读：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启第二个事务，并修改id=1的name值，但是不提交：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; update tx_test set name</span>=<span class="string">'luge'</span> where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Rows matched: 1  Changed: 1  Warnings: 0</span></span></pre></td></tr></table></figure></li>
<li>回到第一个窗口，再进行一次id=1的查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tx_test where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | luge |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure>
可以看到，id=1的name值已经由<strong>lu</strong>修改为<strong>luge</strong>。事务1读取了事务2执行但是未提交的结果。  </li>
</ol>
<h5 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h5><p>在读已提交的隔离级别当中，当前事务可以读取其他事务已经提交的执行结果。这就出现了不可重复读的问题，也就是在同一个事务当中两次或多次执行同一个sql，得到的结果不一致。实验如下：</p>
<ol>
<li>设置当前会话隔离级别为读已提交：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read committed;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启事务，并在当前事务中进行一次查询（id=1）：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; select * from tx_test where id </span>= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | lu   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">```  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">3. 打开另一个会话，设置会话隔离级别为读已提交：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">```java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; set session transaction isolation level read uncommitted</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启第二个事务，并修改id=1的name值，但是不提交：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; update tx_test set name</span>=<span class="string">'luge'</span> where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Rows matched: 1  Changed: 1  Warnings: 0</span></span></pre></td></tr></table></figure></li>
<li>回到第一个窗口，再进行一次id=1的查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tx_test where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | lu   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">```  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">可以看到，id</span>=<span class="number">1</span>的name值还是**lu**，也就是这个隔离级别消除了未提交读带来的脏读。  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span>. 此时回到第二个窗口，进行一次事务的提交：</span></pre></td></tr><tr><td class="code"><pre><span class="line">```java</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; commit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>切换至第一个窗口，再进行一次id=1的查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tx_test where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | luge |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure>
此时可以看到，在第二个事务对id=1的修改提交（commit）之后，第一个事务能够看到第二个事务提交的内容，读取了第二个事务提交的内容。此时也带来了另一个一致性问题：也就是在同一个事务中，两次请求读取的数据不一致，这就是不可重复读。</li>
</ol>
<h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>可重复读可以理解为，在同一个事务当中，多次执行同一个sql，返回的结果是一致的，不会受到其他事物的影响。实验如下：</p>
<ol>
<li>设置当前会话隔离级别为可重复读：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level repeatable read;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启事务，并在当前事务中进行一次查询（id=1）：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; select * from tx_test where id </span>= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | luge |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">```  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">3. 打开另一个会话，设置会话隔离级别为可重复读：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">```java</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; set session transaction isolation level repeatable read</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启第二个事务，并修改id=1的name值，但是不提交：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; update tx_test set name</span>=<span class="string">'lulu'</span> where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Rows matched: 1  Changed: 1  Warnings: 0</span></span></pre></td></tr></table></figure></li>
<li>回到第一个窗口，再进行一次id=1的查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tx_test where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | luge |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">```  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">可以看到，id</span>=<span class="number">1</span>的name值还是**luge**，第二个事务未提交的修改数据对其他事务不可见。</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span>. 此时回到第二个窗口，进行一次事务的提交：</span></pre></td></tr><tr><td class="code"><pre><span class="line">```java</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; commit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>切换至第一个窗口，再进行一次id=1的查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tx_test where id = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | luge |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure>
此时，在第一个事务当中，相同条件的sql执行出来的结果是一致的，即使另一个事务已经进行了commmit操作。在这个事务隔离级别当中（repeatable read），同一个事物执行相同的sql，肯定会得到相同的结果，实现原理就是通过MVCC实现的。可重复读虽然解决了同一个事务不可重复读的问题，但是同时也引发了另外一个问题——幻读。实验如下：</li>
</ol>
<ol>
<li>开启第一个事务，做一次查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; select * from tx_test</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | lulu |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">2</span> | wen  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">3</span> | wen  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">4</span> | shi  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启第二个事务，做一次数据插入并提交：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span>  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt;  insert into tx_test <span class="title">value</span><span class="params">(<span class="number">5</span>, <span class="string">'gou'</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; commit</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.02</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>返回第一个事务，同样做一个与事务二相同的sql插入。插入之前，先查询一边：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tx_test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | lulu |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">2</span> | wen  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">3</span> | wen  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">4</span> | shi  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt;  insert into tx_test <span class="title">value</span><span class="params">(<span class="number">5</span>, <span class="string">'gou'</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">'5'</span> <span class="keyword">for</span> key <span class="string">'PRIMARY'</span></span></pre></td></tr></table></figure>
此时可以发现，查询的时候并没有出现<strong>id=5</strong>的记录，当试图插入的时候，报了唯一键冲突。这就与预期结果不一致了，明明在这个事务里面查询没有这条记录，插入却报错，反馈已经存在，刚才查询的结果就像幻觉一样。这就是幻读。<br>对于范围查询，是可以避免幻读这个问题的。InnoDB存储引擎在repeatable read事务隔离级别下，使用next-key lock算法避免了幻读的产生。现在实验如下：  </li>
</ol>
<ol>
<li>开启第一个事务，做一次<strong>value=3</strong>的查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; select * from tx_test_1 where value </span>= <span class="number">3</span> <span class="keyword">for</span> update;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+-------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | value |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+-------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">2</span> |     <span class="number">3</span> |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+-------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启第二个事务，做一次<strong>id=4</strong>的插入：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; insert into <span class="title">tx_test_1</span><span class="params">(`value`)</span> <span class="title">value</span> <span class="params">(<span class="number">4</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span></pre></td></tr></table></figure>
此时第二个事物的insert会被阻塞住，直到超时回滚。第一个事务通过select…for update的方式，对<strong>value=3</strong>加了Record Lock和Next-Key Lock。可以看到前面的建表语句（tx_test_1）,列<strong>value</strong>是辅助索引，对于辅助索引，select…for update方式会对记录添加行锁和间隙锁。对此，对唯一主键列<strong>id</strong>（id=2）添加了行锁，对辅助索引列<strong>value</strong>（value=3）添加了（3，5）的Next-key lock，所以第二个事务进行<strong>value=4</strong>的插入的时候，由于锁的存在导致insert失败。这样就避免了在RR隔离级别下可能会出现的幻读。<br>这里需要注意一点的问题就是，select…for update会给唯一主键列所在的行添加行锁，如果where条件为辅助索引，则会对辅助索引添加next-key lock（间隙锁），锁住下一个值区间。  </li>
</ol>
<h5 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h5><p>串行化是最高的事务隔离级别，每个事务在执行的时候都会加上相应的锁，使之不可能冲突。实验如下：  </p>
<ol>
<li>设置隔离级别为串行化，开启第一个事务，并且做一次查询：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt;  set session transaction isolation level serializable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; begin</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">mysql&gt; select * from tx_test</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+-------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">| id | name  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+-------+</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">1</span> | lulu  |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">2</span> | wen   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">3</span> | wen   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">4</span> | shi   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">5</span> | gou   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">6</span> | right |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">7</span> | right |</span></pre></td></tr><tr><td class="code"><pre><span class="line">|  <span class="number">9</span> | wrong |</span></pre></td></tr><tr><td class="code"><pre><span class="line">+----+-------+</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span></pre></td></tr></table></figure></li>
<li>开启第二个事务，先查询，再尝试一次插入：<pre><code class="java">mysql&gt;  set session transaction isolation level serializable;
Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span>
<span class="function">mysql&gt; begin</span>;
Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span>
<span class="function">mysql&gt; insert into tx_test <span class="title">value</span><span class="params">(<span class="number">100</span>, <span class="string">'change'</span>)</span></span>;</code></pre>
此时这个insert语句会阻塞住直到第一个事务提交commit或者回滚rollback释放锁。由此可以看到，在串行化隔离级别上，事务之间的读取是互相不受影响的，添加的共享锁。但是事务的插入是排他锁，必须串行执行，这样就完全实现了事物之间的隔离属性。  </li>
</ol>
<h4 id="MVCC——多版本并发控制"><a href="#MVCC——多版本并发控制" class="headerlink" title="MVCC——多版本并发控制"></a>MVCC——多版本并发控制</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>如上面隔离级别分析，在可重复读（RR）隔离级别下，通过MVCC避免了提交读情况下的不可重复读问题，下面来仔细分析下MVCC是如何实现在同一个事务中可重复读的。<br>MVCC是通过保存数据在某个时间点的快照来实现重复读的，也就是说，保存了每条记录的变更之前的版本，并通过版本号实现记录和控制。InnoDB的MVCC是通过在每行记录后面两个隐藏的列来实现。这两个列，分别保存了这个行的创建版本号，一个保存的是行的删除版本号，指系统版本号（可以理解为事务的ID），每开始一个新的事务，系统版本号就是自动递增，事务开始时刻的系统版本号会作为事务的ID。  </p>
<h5 id="增删改查如何实现MVCC"><a href="#增删改查如何实现MVCC" class="headerlink" title="增删改查如何实现MVCC"></a>增删改查如何实现MVCC</h5><p>1.（事务T1）插入一条数据（INSERT），记录的版本号即当前事务的版本号。假设事物的id为1.</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>create version</th>
<th>delete version</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>test</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>2.（事务T2）对这条数据进行更新（UPDATE），采取的动作时先标记为已删除，删除的版本号就是事务的id，同时insert一条新的记录。比如此时事务的id为2，把name修改为change。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>create version</th>
<th>delete version</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>test</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>change</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>3.（事务T3）删除（delete）操作的时候，就把事务id作为删除版本号。比如此时事物的id为3.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>create version</th>
<th>delete version</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>test</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>change</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>4.查询（SELECT）操作，在查询时要符合以下两个条件的记录才能被事务查询出来：<br>4.1.创建版本号小于等于当前事物的版本号（事务id）。<br>4.2.删除版本号未指定或者大于当前事务版本号。即确保事务读取到的行，在事务开始之前未被删除。<br>如事务T1在T3操作完成之后，继续原条件查询的话，会匹配出创建版本小于等于T1版本号id=1且删除版本号大于本身版本号的那一条记录。也就是：  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>create version</th>
<th>delete version</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>test</td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<h5 id="数据读取相关"><a href="#数据读取相关" class="headerlink" title="数据读取相关"></a>数据读取相关</h5><p>快照读：读取的是快照版本，也就是历史版本。<br>当前读：读取的是最新版本</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2019/03/30/MySql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><p>事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存，是访问并更新数据库中各种数据项的一个执行单元。</p>
<h3 id="事务的特性：ACID"><a href="#事务的特性：ACID" class="headerlink" title="事务的特性：ACID"></a>事务的特性：ACID</h3><h4 id="A（Atomicity）原子性"><a href="#A（Atomicity）原子性" class="headerlink" title="A（Atomicity）原子性"></a>A（Atomicity）原子性</h4><p>原子性是指整个数据库事务是不可分割的工作单元，即要么都做，要么都不做。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p>
<h4 id="C（consistency）一致性"><a href="#C（consistency）一致性" class="headerlink" title="C（consistency）一致性"></a>C（consistency）一致性</h4><p>一致性指事务将数据库从一种状态转变为下一种一致的状态，在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>
<h4 id="I（isolation）隔离性"><a href="#I（isolation）隔离性" class="headerlink" title="I（isolation）隔离性"></a>I（isolation）隔离性</h4><p>事物的隔离性要求每个读写事物的对象对其他事物的操作对象能互相分离，即该事务提交前对其他事物都不可见，通常使用锁来实现。</p>
<h4 id="D（durability）持久性"><a href="#D（durability）持久性" class="headerlink" title="D（durability）持久性"></a>D（durability）持久性</h4><p>事务一旦提交，其结果就是永久性的。即使发生宕机，数据库也能将数据恢复。</p>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><h4 id="事务隔离性的实现"><a href="#事务隔离性的实现" class="headerlink" title="事务隔离性的实现"></a>事务隔离性的实现</h4><p>MySQL通过锁实现了事务隔离性特性。</p>
<h5 id="锁的定义"><a href="#锁的定义" class="headerlink" title="锁的定义"></a>锁的定义</h5><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。</p>
<h5 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h5><p>InnoDB存储引擎支持行级锁，实现了两种类型的行级锁：</p>
<ul>
<li>共享锁（S Lock），允许事务读取一行数据。</li>
<li>排他锁（X Lock），允许事务删除或更新一行数据。</li>
</ul>
<p>如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容。如果事务T3想获得行r的排他锁，则其必须等待事务T1、T2释放行r上的共享锁——共享锁和排他锁不兼容。兼容性如下：</p>
<p> | X | S<br>-|-|-<br>X | 不兼容 | 不兼容<br>S | 不兼容 | 兼容<br>X锁与其他都不兼容，只有S锁相互兼容，S、X锁都是行级锁。</p>
<p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一个额外的锁方式，称之为意向锁/意向锁是指将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。若将上锁的对象看成一棵树，对最底层行级别加锁，首先需要对上层粗粒度的对象（数据库、表）加意向锁。<img src="/2019/03/30/MySql%E4%BA%8B%E5%8A%A1/locktree.PNG" alt="层次结构"></p>
<p>比如针对记录r加X锁，需要分别对数据库A，表、页上加意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例：在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已经存在S锁，之后事务需要对记录r在表1上加IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<p>InnoDB存储引擎支持意向锁设计比较简单，意向锁即为表级别的锁。设计目的主要是为了在一个事物中解析下一行将被请求的锁类型。所支持的两种意向锁如下：</p>
<ul>
<li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>表级意向锁与行级意向锁兼容性如下：</p>
<table>
<thead>
<tr>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<h5 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h5><p> MySQL通过行多版本控制的方式来实现一致性的非锁定读。读取正在进行update或者delete的数据行时，实际上读取的此行的快照数据，从而避免了其他事物锁定当前行的情况下读等待（等待行锁的释放）的情况。非锁定读极大地提高了数据库的并发性，读取不会占用和等待表上的锁。但是在不同的事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读。即使都是使用非锁定的一致性读，但是对于快照数据的定义也各不相同。</p>
<p> 快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本，称之为行多版本技术。由此带来的并发控制称之为多版本并发控制。</p>
<p> 在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB存储引擎使用非锁定的一致性读。然而对于快照数据的定义不相同：在READ COMMITTED隔离级别下，非一致性读总是读取被锁定行的最新一份快照数据；在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>
<p> MVCC（多版本并发控制）和MySQL事务隔离级别，将专门介绍。</p>
<h5 id="一致性锁定度"><a href="#一致性锁定度" class="headerlink" title="一致性锁定度"></a>一致性锁定度</h5><p> MySQL的InnoDB存储引擎默认的隔离级别为REPEATABLE READ，select操作使用一致性非锁定读。某些情况下，用户需要显示地针对数据库读取操作进行加锁保证数据逻辑的一致性。InnoDB存储引擎对于select语句支持两种一致性的锁定读操作：</p>
<ul>
<li><p>select … for update</p>
</li>
<li><p>select … lock in share mode  </p>
<p>select … for update对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。select … lock in share mode读读取的行记录加一个S锁，其他事物可以向被锁定的行加S锁，如果加X锁，将会被阻塞。</p>
<p>对于一致性非锁定读，即使读取的行已经被执行了 select … for update，也是可以进行读取的。select … for update和select … lock in share mode必须在一个事务中，事务提交了，锁也就释放了。</p>
</li>
</ul>
<h5 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h5><ol>
<li>Record Lock：单个行记录上的锁<br>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</li>
<li>Gap Lock：间隙所，锁定一个范围，但不包含记录本身  </li>
<li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身<br>Next-Key Lock结合了Gap Lock和Record Lock的一种锁定算法，设计的目的是为了解决幻读（以后介绍）。当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</li>
</ol>
<h5 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h5><ol>
<li>脏读<br>提到脏读，就涉及到脏数据和脏页的概念。脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘中的页的数据是不一致的。在刷新到磁盘之前，日志都已经被写入到了重做日志文件。脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交。<br>对于脏页的读取，是正确的。脏页是指数据库实例内存和磁盘的异步造成的，不会影响数据的一致性（脏页最终都会刷新到磁盘中）。<br>脏数据是指未提交的数据，也就是两个事务，其中一个事务对数据进行了修改但是还未提交，另一个事务读取了未提交的数据。这就违反了数据库的隔离性。</li>
<li>不可重复读<br>不可重复读是指在同一个事务多次读取同一数据集合，结果集有差异的情况。两个事务，其中一个事务访问了一个数据集合，另一个事务同样也访问了同一个数据集合，并做了一些DML操作。第一个事务在进行读取时，返回了与第一次不一致的结果，这就发生了在同一个事务内两次读到的数据是不一样的情况。这就是不可重复读。<br>脏读是读取到未提交的数据，不可重复读读到的是已经提交的数据，但是违反了数据库事务一致性的要求。</li>
<li>幻读<br>幻读是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。幻读主要是针对读取结果条目数不同。</li>
<li>更新丢失<br>更新丢失就是一个事物的更新操作会被另一个事物的更新操作所覆盖，从而导致数据的不一致。</li>
</ol>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。如果没有外力介入，事务都将无法推进下去。针对死锁问题，有两种解决方案：  </p>
<ol>
<li>死锁检测<br>数据库一般采用wait-for graph（等待图）的方式来进行死锁检测，这是一种比较积极主动的死锁检测方式，起到了一个预防的作用。数据库会保存两种信息：1，锁的信息链表；2，事务等待链表。这两种链表可以构造一张图，若存在回路，就代表存在死锁，因此资源间互相发生等待。每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常InnoDB存储引擎选择回滚undo量最小的事务。</li>
<li>超时机制<br>当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。InnoDB存储引擎中的innodb_lock_wait_timeout用来设置超时时间。</li>
</ol>
<h4 id="事务原子性、一致性、持久性的实现"><a href="#事务原子性、一致性、持久性的实现" class="headerlink" title="事务原子性、一致性、持久性的实现"></a>事务原子性、一致性、持久性的实现</h4><p>MySQL通过redo log和undo log实现了A、C、D的特性。redo log称为重做日志，用来保证事物的原子性和持久性，。undo log用来保证事物的一致性，帮助事务回滚及MVCC功能。redo和undo都可以视为一种恢复操作，redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。redo通常记录的是物理日志，记录的是页的物理修改操作；undo是逻辑日志，根据每行记录进行记录。</p>
<h5 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h5><ol>
<li>概念和功能<br>重做日志用来实现事务的持久性，即事务的ACID中的D。由两部分组成：一是内存中的重做日志缓冲（redo log buffer），是易失的；二是重做日志文件（redo log file），其是持久的。<br>InnoDB存储引擎通过Force Log at Commit机制实现事物的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。redo log是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。而undo log是需要进行随机读写的。<br>为了确保每次重做日志都写入重做日志文件，每次都将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作。重做日志缓冲先写入文件系统缓冲，为了确保重做日志写入磁盘，必须进行一次fsync操作。由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。<br>innodb_flush_log_at_trx_commit控制重做日志刷新到磁盘的策略。1代表事务提交时必须调用一次fsync操作；0表示事务提交时不进行写入重做日志操作，这个操作在master thread中完成，master thread每1秒会进行一次重做日志文件的fsync操作；2表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作，数据库宕机但是操作系统不宕机时，并不会导致事物的丢失。</li>
</ol>
<h5 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h5><ol>
<li>概念和功能<br>事务如果需要回滚，就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样用户执行事务失败，或者主动发起rollback语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。<br>undo是逻辑日志，只是将数据库逻辑的恢复到原来的样子。所有的修改都逻辑地取消了，但是数据结构和页本身在回滚之后可能不相同。<br>InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每一个INSERT，InndoDB存储引擎会完成一个DELETE；对于每一个DELETE，InnoDB存储引擎会执行一个INSERT；对于每一个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改的行放回去。<br>除了回滚，undo的另一个作用是MVCC，在InnoDB存储引擎中MVCC是通过undo来完成的。当用户读取一行记录，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。<br>undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</li>
<li>undo log格式  </li>
<li><ol>
<li>insert undo log。指在insert操作过程中产生的undo log。因为insert操作的记录支队事务本身可见，对其他事务不可见，所以该undo log可以在事务提交后直接删除，不需要purge操作。  </li>
</ol>
</li>
<li>2 update undo log。指的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>流程引擎设计概要</title>
    <url>/2018/12/10/%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<h3 id="模型概念"><a href="#模型概念" class="headerlink" title="模型概念"></a>模型概念</h3><h4 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h4><p>workflow对应一次工作流，一次具体的工作流转状态，其中携带了流程运转的上下文信息。</p>
<h4 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h4><p>transaction代表请求，它驱动了workflow的运转。一个或者多个transaction共同驱动workflow到达终态。</p>
<h4 id="stop-condition"><a href="#stop-condition" class="headerlink" title="stop_condition"></a>stop_condition</h4><p>stop_condition代表终态条件，或者工作流结束状态，当执行完对应的操作后能与某一条stop_condition相匹配，则代表workflow可以达到停止状态。</p>
<h4 id="activity"><a href="#activity" class="headerlink" title="activity"></a>activity</h4><p>activity代表流程节点，workflow通过条件转换达到某个具体activity，通过activity完成此次事件变迁。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>process挂载在activity下，它是activity的具体执行者，可以是下游外部系统的rpc调用，也可以是上下文信息的重组装。process是可以复用，也就是同一个process可以挂载在多个不同的activity下面。</p>
<h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><p>transition代表条件转换，每次执行完一个activity，上下文信息中保存了执行每个activity的处理结果和状态，通过状态的组合完成对transition的匹配，寻找下一个流程节点。<br>整体的流程概念如下图：<img src="/2018/12/10/%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/workflow.PNG" alt="流程引擎"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>流程引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM基础</title>
    <url>/2018/10/20/JVM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>JVM运行时数据区主要分为五大块：程序计数器、Java虚拟机栈、本地方法栈、堆和方法区。模型如下图:<img src="/2018/10/20/JVM%E5%9F%BA%E7%A1%80/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="jvm运行时数据区"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器可以看作是当前线程所执行字节码的行号指示器。虚拟机的字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。它是线程私有的，每条线程都有自己独立的程序计数器，为了保证线程切换后能恢复到正确的执行位置。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈也是线程私有的，与线程的生命周期相同。描述的是Java方法执行的内存模型：每个方法在执行时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法的调用和返回对应栈帧在虚拟机中的入栈和出栈。</p>
<p>虚拟机栈有两种异常状况：1，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。2，如果虚拟机可以动态扩展，扩展是无法申请到足够的内存，将抛出OutOfMemoryError异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈类似，本地方法栈为虚拟机使用到的Native方法服务，也会抛出StackOverflowError或者OutOfMemoryError异常。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。所有的对象实例和数组都在堆上分配。</p>
<p>Java堆是垃圾收集器管理的主要区域，在内存回收的角度来看，Java堆还可以细分为：新生代（Eden、From Survivor、To Suivivor）和老年代。</p>
<p>Java堆的内存空间类似与磁盘空间，逻辑上连续，物理上可以不连续。如果堆内存不能继续进行实例分配，将会抛出OutOfMemoryError异常。</p>
<h4 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h4><p>方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。内存空间的分配与Java堆一样，逻辑上连续物理上不要求连续。</p>
<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。编译好的Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。<br>运行时常量池是方法区的一部分，受到方法区内存的限制，会抛出OutOfMemoryError异常。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明手册——再谈Git版本</title>
    <url>/2018/09/26/Git%E6%89%8B%E5%86%8C%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>上节我们了解到版本回退相关的几个操作，回退到上一个版本<code>git reset --hard HEAD^</code>或者通过<code>git reset --hard commit-id</code>来跳转到相应的版本。同时可以通过<code>git reflog</code>查看操作的历史纪录和注释等信息。这里我们提到的版本跳转是通过本地版本仓库的版本覆盖暂存区和工作区。这就又回到了我们第一小节讲到的三个空间：工作区、暂存区、本地版本库，那么版本回退过程中，几个空间如何回退跳转？</p>
<h4 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h4><p>首先查看一下我们的版本历史纪录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">f5da69a6bdf6a44d75f7b4088b2d26d59abe497f add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb52623011006575566736bc0c387107dae5c6 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3125251</span>a15943118724f9dce6302c7351444880e Update README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9e7674</span>cbd635f8e52e2434113e05479bf7281b9d Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">68</span>c86da5dc6372755fe7048847aed6cd9b8f001f add java9</span></pre></td></tr></table></figure>
<p>此刻我们修改go.txt文件，随便做一些修改。然后此时我们查看一下当前的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span></pre></td></tr><tr><td class="code"><pre><span class="line"> (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       modified:   go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">no changes added to <span class="title">commit</span> <span class="params">(use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span></span></span></pre></td></tr></table></figure>
<p>可以发现提示我们可以add到暂存区。如果我们想撤销刚才对go文件的修改怎么办？只是想要工作区的内容回退到和暂存区内容一致。此时我们使用<code>git checkout -- file</code>，file就是需要回退的文件名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git checkout -- go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$  git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">nothing to commit, working directory clean</span></pre></td></tr></table></figure>
<p>其实git checkout就是将暂存区的内容覆盖掉工作区的内容。我们通过<code>git status</code>可以看到当前工作区处于干净的状态。打开go.txt文件一看发现刚才添加的内容已经消失了。</p>
<h4 id="撤销暂存区的修改"><a href="#撤销暂存区的修改" class="headerlink" title="撤销暂存区的修改"></a>撤销暂存区的修改</h4><p>刚才演示了在工作区修改没有add到暂存区的版本回退，当我们使用了add命令将修改同步到了暂存区，再想回退上一个暂存区的版本。我们实际操作一把，同样修改go.txt，add到暂存区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line"> (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">       modified:   go.txt</span></pre></td></tr></table></figure>
<p>我们add之后可以看到git给出了提示：use “git reset HEAD <file>…” to unstage。提示我们使用reset HEAD file可以取消保存。</file></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$  git reset HEAD go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">Unstaged changes after reset:</span></pre></td></tr><tr><td class="code"><pre><span class="line">M       go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        modified:   go.txt</span></pre></td></tr></table></figure>
<p>此刻我们再查看当前的状态，发现git提示我们要么通过add 添加到暂存区来准备commit，要么再通过上面checkout的方式来丢弃本次在工作区的修改。又回到了上面的流程。其实此时就是我们修改了工作区的内容，但是处于未同步到暂存区的状态。</p>
<h4 id="撤销本地版本仓库的修改"><a href="#撤销本地版本仓库的修改" class="headerlink" title="撤销本地版本仓库的修改"></a>撤销本地版本仓库的修改</h4><p>那就是我们上一节提到的<code>git reset --hard HEAD^</code>或者<code>git reset --hard commit-id</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一小节我们详细介绍了三个空间（工作区、暂存区、本地版本库）版本的修改方式。这使得我们的开发更加方便灵活。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明手册——分支与版本的故事</title>
    <url>/2018/09/24/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>上一节熟悉了一下git远程仓库相关的知识。远程仓库和本地仓库一样，保存了分支与版本的各种信息。那么什么是分支与版本呢？<br>所谓分支，简单理解可以把分支比喻作为生长的树，多人协同开发过程中，每个人都在自己的分支上开发，也就是树的各个树枝。这就体现了主干和分支的概念，树的主干就是我们的master分支，分支就是我们基于主干或者其他分支创建出来的分支。</p>
<h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><p>那么怎么可以查看当前git目录里面的所有分支呢？命令为git branch。我们可以在当前的git仓库目录下面执行git brach查看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch</span></pre></td></tr><tr><td class="code"><pre><span class="line">* master</span></pre></td></tr></table></figure>
<p>可以看到master和前面带着的<em>，首先</em>代表我们当前处理的分支，这个分支叫做master。我们一般称master这个分支为主干分支，也就是我们前面提到的树的主干。master分支作为开发的主干分支，其他分支都是基于主干checkout出来进行开发（当然也可以checkout其他分支）。这个master分支对应于我们上节提到的远程仓库里面的master分支，我们起名远程仓库为origin，则它就对应origin/master。git branch -v，添加-v可以查看分支的版本号和当前提交的注释。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">* master <span class="number">9f</span>fb526 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr></table></figure>
<p>可以看到当前只有一个分支master，版本号前几位为9ffb526，提交的注释为“Merge branch ‘master’ of github.com:VfEver/rushgit”。</p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>创建分支命令为git branch [name]。例如git branch dev，就创建了一个名字叫做dev的分支，此时我们再用git branch -v查看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">  dev    <span class="number">9f</span>fb526 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line">* master <span class="number">9f</span>fb526 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr></table></figure>
<p>可以看到现在有了两个分支，一个主干分支master，一个基于master的dev分支。此时我们还处于master分支（星号在master），两个分支的版本号和注释都是一样的。<br>接下来我们通过git checkout命令切换分支。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'dev'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch</span></pre></td></tr><tr><td class="code"><pre><span class="line">* dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">  master</span></pre></td></tr></table></figure>
<p>此时我们就把我们工作区分支切换到了dev。dev工作区内容和master分支的内容完全一致。接下来我们执行一次提交。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ touch go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"add go.txt"</span></span></pre></td></tr></table></figure>
<p>再切回master分支，就会发现我们在dev分支的修改并没有影响到master分支。当前master分支目录下面并没有go.txt这个文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Switched to branch <span class="string">'master'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ ls -l</span></pre></td></tr><tr><td class="code"><pre><span class="line">total <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span> <span class="number">137</span> Sep <span class="number">24</span> <span class="number">01</span>:<span class="number">53</span> README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span>  <span class="number">42</span> Oct <span class="number">29</span>  <span class="number">2017</span> java9.txt</span></pre></td></tr></table></figure>
<p>在当前目录下面，我们再介绍两个命令，merged和no-merged：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git --merged</span></pre></td></tr><tr><td class="code"><pre><span class="line">* master</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git --no-merged</span></pre></td></tr><tr><td class="code"><pre><span class="line">  dev</span></pre></td></tr></table></figure>
<p>–merged是指当前分支合并过哪些分支，–no-merged是指还有哪些分支没有被合并。可以看到我们刚才创建的dev分支并没有合并到master。接下来我们尝试一下分支合并。</p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>使用git merge [name]来讲name分支合并到当前分支。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">Updating <span class="number">9f</span>fb526..f5da69a</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"> go.txt | <span class="number">1</span> +</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ ls -l</span></pre></td></tr><tr><td class="code"><pre><span class="line">total <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span> <span class="number">137</span> Sep <span class="number">24</span> <span class="number">01</span>:<span class="number">53</span> README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span>  <span class="number">12</span> Sep <span class="number">24</span> <span class="number">16</span>:<span class="number">51</span> go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span>  <span class="number">42</span> Oct <span class="number">29</span>  <span class="number">2017</span> java9.txt</span></pre></td></tr></table></figure>
<p>此时就可以看到go.txt这个文件出现在了master分支。将dev分支合并到master分支后，go这个文件夹出现在了我们的工作仓库当中。如何查看整体的提交记录？此时又引出一个命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git log --graph --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">* f5da69a6bdf6a44d75f7b4088b2d26d59abe497f add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">*   <span class="number">9f</span>fb52623011006575566736bc0c387107dae5c6 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line">|\</span></pre></td></tr><tr><td class="code"><pre><span class="line">| * <span class="number">3125251</span>a15943118724f9dce6302c7351444880e Update README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">| * <span class="number">9e7674</span>cbd635f8e52e2434113e05479bf7281b9d Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">* <span class="number">68</span>c86da5dc6372755fe7048847aed6cd9b8f001f add java9</span></pre></td></tr></table></figure>
<p>通过这个命令我们可以根据图形化的提交记录来查看分支提交树，而且分支的信息也特别明确。</p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>删除分支就很简单了，-b参数后面添加要删除的分支名称。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Deleted branch <span class="title">dev</span> <span class="params">(was f5da69a)</span>.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">$ git branch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">* master</span></span></pre></td></tr></table></figure>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>所谓版本，可以简单理解为每次commit记录。每一次commit都会生成一个commit-id，这个commit-id代表一次提交的标识，前面我们看到的git log或者git branch -v也好，在后面都跟着一串字符串，包含数字和字母，这就是commit-id。我们可以称这些commit-id为不同的版本，后续我们的版本操作基本上就是根据commit-id来进行操作。</p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>现在我们处于master分支，由上面的命令行可以看到一共有5次版本记录，每次版本记录后面都有本次commit注释。现在我们尝试将版本回退到上一个版本，也就是从f5da69回退到9ffb526。回退版本有两种方式，通过HEAD回退和通过commit-id回退。    </p>
<ol>
<li>通过HEAD回退<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now at <span class="number">9f</span>fb526 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr></table></figure>
HEAD指向头节点，也就是f5da69节点。^代表上一个版本，是针对f5da69版本的上一个版本。此时我们可以看到命令行里面的输出为HEAD现在指向了9ffb526这个节点。那版本库究竟发生了什么？我们仔细查看一下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$  ls -l</span></pre></td></tr><tr><td class="code"><pre><span class="line">total <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span> <span class="number">137</span> Sep <span class="number">24</span> <span class="number">01</span>:<span class="number">53</span> README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> zys <span class="number">197609</span>  <span class="number">42</span> Oct <span class="number">29</span>  <span class="number">2017</span> java9.txt</span></pre></td></tr></table></figure>
可以发现从dev分支合并过来的go.txt消失了。此时我们就完成了从f5da69回退到9ffb526这个版本。命令中一个^代表上一个版本，两个^^代表上两个版本…以此类推。当我们想回退多个版本的时候，需要写多个^？这就引出了第二种版本回退的方法。</li>
<li>通过commit-id回退<br>通过commit-id我们也可以进行版本回退。现在我们处在9ffb526这个commit-id，我们想要再回退一次commit，则可以将上述命令的HEAD部分可以修改为想要回退的版本号，也就是想要回退的commit-id。如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git reset --hard <span class="number">3125251</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now at <span class="number">3125251</span> Update README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3125251</span>a15943118724f9dce6302c7351444880e Update README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9e7674</span>cbd635f8e52e2434113e05479bf7281b9d Initial commit</span></pre></td></tr></table></figure>
此时我们可以看到，master分支的当前版本已经回退到Update README.md这个注释版本。再继续说明一下，通过commit-id方式不仅可以回退到上一个版本，还可以回退到任何版本，只要能拿到想要跳转的版本commit-id。所以这个命令不仅可以回退，还可以前进到某个历史版本。比如现在我们前进到最后的一个commit，它的commit-id为f5da69a，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git reset --hard f5da69a</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now at f5da69a add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">f5da69a6bdf6a44d75f7b4088b2d26d59abe497f add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb52623011006575566736bc0c387107dae5c6 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3125251</span>a15943118724f9dce6302c7351444880e Update README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9e7674</span>cbd635f8e52e2434113e05479bf7281b9d Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">68</span>c86da5dc6372755fe7048847aed6cd9b8f001f add java9</span></pre></td></tr></table></figure>
此时再看，所有的版本记录又都回来了。但是，当我们不知道我们想要会退的commit-id时候呢？<h4 id="版本查询"><a href="#版本查询" class="headerlink" title="版本查询"></a>版本查询</h4>当我们不记得我们需要回退的commit-id时，可以通过git reflog命令查看我们所有的操作记录，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git reflog</span></pre></td></tr><tr><td class="code"><pre><span class="line">f5da69a HEAD@&#123;<span class="number">0</span>&#125;: reset: moving to f5da69a</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3125251</span> HEAD@&#123;<span class="number">1</span>&#125;: reset: moving to <span class="number">3125251</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb526 HEAD@&#123;<span class="number">2</span>&#125;: reset: moving to HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line">f5da69a HEAD@&#123;<span class="number">3</span>&#125;: merge dev: Fast-forward</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb526 HEAD@&#123;<span class="number">4</span>&#125;: checkout: moving from dev to master</span></pre></td></tr><tr><td class="code"><pre><span class="line">f5da69a HEAD@&#123;<span class="number">5</span>&#125;: commit: add go.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb526 HEAD@&#123;<span class="number">6</span>&#125;: checkout: moving from master to dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb526 HEAD@&#123;<span class="number">7</span>&#125;: pull origin master: Merge made by the <span class="string">'recursive'</span> strategy.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">68</span>c86da HEAD@&#123;<span class="number">8</span>&#125;: commit (initial): add java9</span></pre></td></tr></table></figure>
通过git reflog命令可以看到我们所有的操作记录，每个操作都有一个commit-id，代表一次提交记录，前面的十六进制的号码就是当前操作记录的commit-id，所以可以通过这些commit-id进行任意穿梭。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>这个小节主要学习了版本和分支的基本操作，分支使我们协同开发更加方便，版本控制使我们对版本掌控力度更大。至此，我们算是一只脚踏进了gay交友的大门。处理之外，git还有什么好玩的操作？如何让我们使用起来更加优雅、更加专业？git怎么控制版本？.git目录是为了好看？</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明手册——远程仓库</title>
    <url>/2018/09/23/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Git远程仓库简介"><a href="#Git远程仓库简介" class="headerlink" title="Git远程仓库简介"></a>Git远程仓库简介</h3><p>上一节讲到了Git的本地开发方式，类似于本地一个版本仓库，存储在本机的磁盘中。对于自己开发当然可以直接搞，本地版本管理，本地提交等等。但是对于多人协同工作，就需要建立一个远程存储代码和版本历史的仓库，我们可以成这个仓库为远程仓库，存储我们代码的提交历史，维护代码变动。<br>由于我们前一小结提到过，git是一个分布式的版本控制工具，也就是说，即使存在远程仓库，本地也会保留一个完整的版本记录。</p>
<h4 id="建立远程仓库"><a href="#建立远程仓库" class="headerlink" title="建立远程仓库"></a>建立远程仓库</h4><p>首先要有远程仓库，所以我们先去github上面手动创建一个远程仓库，创建细节不再描述，创建完成之后我们可以拿到对应这个git远程仓库的ssh链接：<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:VfEver/rushgit.git。好了，第一步就简单的完成了。</p>
<h4 id="本地仓库与远程仓库连接"><a href="#本地仓库与远程仓库连接" class="headerlink" title="本地仓库与远程仓库连接"></a>本地仓库与远程仓库连接</h4><p>建立了远程仓库，那么如何让本地仓库与远程仓库建立连接呢？这个连接又是什么意思呢？<br>连接指的就是本地与远程的一个纽带，一个相互关系。本地的修改可以提交到远程仓库，也可以从远程仓库同步代码到本地代码仓库当中。建立连接有两种方式：  </p>
<ol>
<li>本地还未初始化git仓库，可以直接git clone。如下：   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git clone git<span class="meta">@github</span>.com:VfEver/rushgit.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cloning into <span class="string">'rushgit'</span>...</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Enumerating objects: <span class="number">6</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">remote: Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Checking connectivity... done.</span></pre></td></tr></table></figure>
此时相当于把远程仓库的所有东西全部copy到本地，或者说down到了本地。那么当前的这个目录就是本地仓库，并且和远程仓库的master分支（分支下一节介绍）一致。</li>
<li>当本地已经存在一个仓库，此时只是想把本地仓库和远程仓库做一个关联，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$  git remote add origin git<span class="meta">@github</span>.com:VfEver/rushgit.git</span></pre></td></tr></table></figure>
git remote add [名称] [地址]<br>这样就将本地的仓库与远程的分支建立了连接，我们将远程的仓库起名为origin，当然也可以起名为其他的名字，默认规范为origin，表明这个仓库为远程源仓库。我们创建仓库的时候初始化了一个README.md文档，本地是没有这个文件的，所以我们需要把远程仓库的东西同步到我们本地代码，此时就需要引入接下来的命令。</li>
<li>将远程仓库变动同步到本地仓库<br>将远程仓库变动同步到本地仓库，就是使用git pull一个命令，同时需要跟上远程仓库的名称和分支。上面建立关联的过程中我们使用了origin这个名称，分支一直使用master。所以命令以及输出如下：    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git pull origin master</span></pre></td></tr><tr><td class="code"><pre><span class="line">From github.com:VfEver/rushgit</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * branch            master     -&gt; FETCH_HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> README.md | <span class="number">3</span> +++</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">1</span> file changed, <span class="number">3</span> insertions(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode <span class="number">100644</span> README.md</span></pre></td></tr></table></figure>
此时我们可以看到pull一个动作将远程的README.md拉取到了本地仓库，并且作了一个merge动作，就是将本地和远程的文件在本地仓库做一个合并。在多人协作或者频繁更改某些文件的时候，是会出现冲突的。由于此次远程和本地的修改不是同一个文件所以并没有冲突。</li>
<li>将本地仓库变动同步到远程仓库<br>刚才我们将远程的变动拉到了本地仓库，那么如何将本地的修改变动同步到远程仓库呢？此时就需要一个推送的命令。push可以将本地的修改推送到远程。push的时候也需要我们将远程仓库名（origin）和分支（master）添加上。命令和输出如下：   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Counting objects: <span class="number">5</span>, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Delta compression using up to <span class="number">4</span> threads.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), <span class="number">537</span> bytes | <span class="number">0</span> bytes/s, done.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Total <span class="number">5</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">To git<span class="meta">@github</span>.com:VfEver/rushgit.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="number">3125251</span>..<span class="number">9f</span>fb526  master -&gt; master</span></pre></td></tr></table></figure>
通过Writing objects：100%可以看到本地的修改已经全部push到了远程master分支。此时我们再通过git log命令查看一下版本记录：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9f</span>fb52623011006575566736bc0c387107dae5c6 Merge branch <span class="string">'master'</span> of github.com:VfEver/rushgit  --merge远程</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3125251</span>a15943118724f9dce6302c7351444880e Update README.md  --远程更新记录</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">9e7674</span>cbd635f8e52e2434113e05479bf7281b9d Initial commit    --远程初始化记录</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">68</span>c86da5dc6372755fe7048847aed6cd9b8f001f add java9         --本地commit记录</span></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>至此，git两个重量级操作已经搞完了，pull拉取和push推送。git协同操作最基本的两个操作就是这两个。掌握了这两个命令，已经算是初步掌握了协同开发的基本技能，但是这也是两个最简单的两个操作。至于后面的分支管理策略、冲突解决，将会在下一小节继续描述。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>对Thread类中join和yield的理解与实践</title>
    <url>/2018/07/16/%E5%AF%B9Thread%E7%B1%BB%E4%B8%ADjoin%E5%92%8Cyield%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="Java中thread的状态"><a href="#Java中thread的状态" class="headerlink" title="Java中thread的状态"></a>Java中thread的状态</h3><ul>
<li>java中thread类的状态体现在java.lang.Thread类的State枚举里。包含以下几种状态：</li>
</ul>
<ol>
<li>NEW，表示线程被创建出来还没真正启动的状态，可以认为是java的内部状态</li>
<li>RUNNABLE，表示线程已经在JVM中执行，可以是在运行，也可以是在等待系统分配给它CPU片段，在就绪队列里面排队</li>
<li>BLOCKED，阻塞表示线程在等待Monitor lock，比如线程通过synchronized去获取某个锁，但是其他线程独占了，那么当前线程处于阻塞状态。或者，读取文件IO过程中的阻塞</li>
<li>WAITING，waiting表示线程正在等待其他线程采取某些操作，生产者消费者模式中，消费者等待（wait），生产者准备数据，然后调用notify通知消费线程继续工作。Thread.join()也会令线程进入等待状态。</li>
<li>TIMED_WAITING，有条件的等待。</li>
<li>TERMINATED，线程意外死亡或者完成使命，终止运行。<h3 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h3></li>
</ol>
<ul>
<li><p>解释：join方法的作用可以理解为同步，使得线程之间的并行执行变为串行执行（可以这么理解，原理是调用join的线程会让出线程锁进入等待状态，后面将分析源码）。</p>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        OneTread one &#x3D; new OneTread();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;------begin------&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        one.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 下面加入join方法，main线程执行就切换为one这个线程来执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">         * 不加入join，则会并行执行main线程和one线程</span></pre></td></tr><tr><td class="code"><pre><span class="line">         *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        one.join();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;------end------&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    static class OneTread extends Thread&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">        public void run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for (int i &#x3D; 0; i !&#x3D; 5; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(&quot;One thread is doing.i &#x3D; &quot; + i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(&quot;one thread is finished.&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li><p>输出,加入join：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------begin------</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">one thread is finished.</span></pre></td></tr><tr><td class="code"><pre><span class="line">------end------</span></pre></td></tr></table></figure></li>
<li><p>不加入join：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------begin------</span></pre></td></tr><tr><td class="code"><pre><span class="line">------end------</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">One thread is doing.i &#x3D; 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">one thread is finished.</span></pre></td></tr></table></figure></li>
<li><p>join(long millis)<br>millis代表线程等待的毫秒数，在此处则代表main线程等待one线程执行millis毫秒，然后再并行执行。</p>
</li>
<li><p>join()源码分析（为描述方便，假设A线程调用B线程join方法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;调用join其实就是调用带参数的join(0)。</span></pre></td></tr><tr><td class="code"><pre><span class="line">public final void join() throws InterruptedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    join(0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li><p>紧接着看带一个参数的join：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> synchronized对B线程对象加锁，调用join方法首先要获取当前对象的锁，获取锁的原因是会调用B线程的wait()方法，而wait方法是必须持有B线程对象的锁才能进行调用，否则会抛出IllegalMonitorStateException。</span></pre></td></tr><tr><td class="code"><pre><span class="line">*&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    throws InterruptedException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long base &#x3D; System.currentTimeMillis();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long now &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (millis &lt; 0) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;如果等待时间&#x3D;0，则直接调用B线程对象的wait(0)方法。循环检测B线程的状态，直到B线程被打断或者B线程执行完毕调用了notify方法唤醒对于B线程的等待队列线程。</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        while (isAlive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wait(0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        while (isAlive()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            long delay &#x3D; millis - now;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (delay &lt;&#x3D; 0) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                break;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wait(delay);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            now &#x3D; System.currentTimeMillis() - base;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p>经过以上的源码阅读，我们发现，其实main线程调用one线程的join方法后，并不是将两个线程串行化执行，而是main线程获取到one线程的同步锁，然后调用了one线程的wait方法释放同步锁进入相对于one线程的等待队列当中。当one线程执行完毕，one线程在exit过程中会调用notify方法来唤醒main线程继续执行。</p>
</li>
</ul>
<hr>
<h3 id="2-yield"><a href="#2-yield" class="headerlink" title="2.yield()"></a>2.yield()</h3><ul>
<li>解释：一个调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。</li>
<li>注意事项：</li>
</ul>
<ol>
<li>Yield是一个静态的原生(native)方法</li>
<li>Yield告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。</li>
<li>Yield不能保证使得当前正在运行的线程迅速转换到可运行的状态</li>
<li>它仅能使一个线程从运行状态转到可运行状态，而不是等待或阻塞状态。</li>
</ol>
<ul>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class YieldTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;start to test the thread.yield.------&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TwoThread threadA &#x3D; new TwoThread(&quot;ThreadA&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TwoThread threadB &#x3D; new TwoThread(&quot;ThreadB&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        threadA.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        threadB.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;end to test the thread.yield.------&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    static class TwoThread extends Thread &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TwoThread(String name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            super(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">        public void run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for (int i &#x3D; 0; i !&#x3D; 5; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                System.out.println(&quot;the current thread:&quot; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        Thread.currentThread().getName() + &quot;.&quot; + i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F;此处加入yield代表线程让出cpu</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Thread.yield();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p>输出，加入yield</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start to test the thread.yield.------</span></pre></td></tr><tr><td class="code"><pre><span class="line">end to test the thread.yield.------</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.3</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.3</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.4</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.4</span></pre></td></tr></table></figure></li>
<li><p>不加入yield</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start to test the thread.yield.------</span></pre></td></tr><tr><td class="code"><pre><span class="line">end to test the thread.yield.------</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.3</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadA.4</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.3</span></pre></td></tr><tr><td class="code"><pre><span class="line">the current thread:ThreadB.4</span></pre></td></tr></table></figure></li>
<li><p>通过查看对应的输入输出我们可以发现，加入yield执行，当前运行线程会让出cpu时间片，然后cpu会选择其他线程执行。在本例当中，ThreadA与ThradB交替轮流执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>承蒙照顾，江湖再见</title>
    <url>/2018/04/22/%E6%89%BF%E8%92%99%E7%85%A7%E9%A1%BE%EF%BC%8C%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81/</url>
    <content><![CDATA[<p>前段时间下班后经常跑步回家。</p>
<p>身体上出了问题，我会跑步来慢慢改善；思想上出了问题，我也尝试通过跑步调节。<br>其实你理性思维解决不了的事情，非理性的手段也是徒劳，只是暂时躲避而已。<br>从公司到家，四公里，不短不长，慢跑经过四五个路口，三十分钟左右，每天的这三十分钟成了我逃避工作和生活最开心的时刻。三四月份郊区的北京挺适合跑步的，开始略微的小冷到后面的大汗淋漓，会让你整个人精神上特别通透。当我在跑步的时候我在想什么？大部分时间都在想还要多久才能到家。不会去想怎么写代码才能写得像诗一样，也不会去想今天那个流程还有没有坑，偶尔会想起人大的烤猪蹄，偶尔会想起可爱的112，偶尔会暗下决心下次要把儿子们喝趴下。当然112和烤猪蹄会多那么一点点，好吧，想念烤猪蹄最多。</p>
<p>跑步回家的这三十分钟，身体上的劳累让思想上超级放松，偶尔也会天马行空。从公司出来往南过完第一个十字路口，戴上耳机思维就开始飘了。瞟着马路上的小汽车、公交车和三轮车，我也会暗暗和他们较量看谁先到终点。当然每次都是我输，我想，这是天然的差距，起跑线的差距，不对等的差距。尽管如此，我每天还要比，总会比，不得不比。然后总是输。但是我脸皮厚心态好，从没因为跑不过他们而拒绝回家。但还是很沮丧，沮丧到一定程度就很超脱，会跳出当前的状态和环境去仔细审视自己，总结自己，这时候往往是最令人失望的。你讨厌的诸如迷茫、没有方向这些青春的词汇确确实实发生在你身上，你尝试去用你的经验去考虑去主导，但是确实让你更加焦虑。想不明白我就不想我就跑呀，跑呀。遇到矛盾我总是用极其理性的思维去尝试解决，比如：六楼左侧电梯出来，右拐68步到工位，左拐72步到工位，计算好各自步数后，4步的差距使我出电梯头也不回右拐，暗暗庆幸今天又省了4步。当理性不再理性不能解释遇到的矛盾了，我开始读闲书，把计算机的扔一边。村上春树也好，马尔克斯也好，历史、情色、人物传记，我都读。我觉得感性思维在解决思想问题上应该比理性思维更胜一筹。就这么读着，跑着，然后砰的一下。</p>
<p>他妈的我就想明白了。</p>
<p>我们总是尝试用以往的经验来解决当前的问题和矛盾，以一个过去式来解决现在式，常规理性的解法，有效但不是最优解。当把时间这个维度加进来，事情就有意思了。从一个四维角度讲，我们生活在一个平行宇宙中，过去各个不同的场景，你课堂上睡过的觉，半夜翻墙上过的网，认认真真刷题的夜晚，各个宇宙交织在一起使你走到了现在。时间往后拉，站在未来的平行宇宙里面，你在办公室里写着代码，或者在家里顶着太阳收拾田地，又或者把酒当歌诗意人生。有很多很多想法，以一个上帝视角观察着自己，并告诉自己当前的每个转变都是对未来某个自己的偏移。<br>跑步回家的时候，我特别期待遇到路口红灯，这样我就有机会有理由说服自己停下来。看到有的车辆不管不顾红灯继续安全前行，我觉得他们敢于打破规则，用更短的时间到达终点。但这又让我想起东京物语所讲，不停往前奔流的人生，和为了理想想要在中途停留的想法，这对矛盾到底哪个更重要更有意义？<br>我想，生活也好，工作也好，正是需要不墨守成规的前行者，和一条有红绿灯的赛道。<br>走吧。</p>
<p>坚定我离开想法的是4月11号那天，10号晚上刚和小伙伴们吃完火锅，早上吃完早餐火急火燎的找厕所，然后我尝到了绝望的滋味。六层，爬了六层，没有找到一个空闲的马桶。没带工牌，有的楼层还刷不开。这么坚持了半个小时，让我想起了高中闹肚子语文老师拖堂的恐怖，导致我一度讨厌语文。当我终于蹲在马桶上，我又想明白了一件事。<br>没有什么是一泡屎不能解决的，如果有，那就两泡。<br>还有一件事，那就是从一楼到六楼一共有152级台阶。<br>吃一堑长一智，从此上厕所记得带工牌。我可真机灵。</p>
<p>我尝试把离别说得轻松愉悦一点，但是啊，每次离别都意味着这么多可爱的人儿啊，可能有些一辈子见不到了。慌慌张张的从起点跑到一个终点，只是为了跑向下一个终点。前路很长，我们都要成长。<br>从7月21号入职，到如今4月21号扳起手指细数过往，整整九个月，我他妈竟然攒了66张公司发的广告纸，一张没丢都被我整整齐齐码在抽屉里。好啦好啦讲完这最后一个笑话。<br>祝你们身体健康。前路漫漫，祝自己有酒有肉有姑娘。</p>
<p>各位，<br>离别总有，重逢可期。承蒙照顾，江湖再见！</p>
<p>赵延升<br>2018年4月21日 晚</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>我的黄金时代</title>
    <url>/2018/03/02/%E6%88%91%E7%9A%84%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3/</url>
    <content><![CDATA[<p>有句话讲，知识就是力量，我深信不疑。于是空闲时间我就会瞎几把读点书，你想，不用去健身房锻炼就可以获得力量，不管怎么算都是稳赚不赔的买卖。力量是什么，力量就是肌肉，就是肉嘛。肉长在肱二头肌上是长，长在脸上也是长。长在肱二头肌上叫肱二头肌，长在脸上叫脸皮。读了点书，脸皮厚了，说话也会有力量了。</p>
<p>我们常提碎片化学习，碎片化阅读。那么，究竟，什么他妈的叫碎片化，这就是一个很有趣儿的理解了。那句话怎么讲，一千个读者就有一千个哈利波特。毫不羞涩的说，我的碎片化就是早上拉屎那段时间。你安安静静地阅读，伴随着稀里哗啦的声音，这，就是碎片化。</p>
<p>我的碎片化是很准时的，九点到九点一刻。偶尔班车晚点堵车一会会儿，连早饭都顾不上吃也要去碎片化。手里捧着手机的碎片化是最舒服的，旁边的厕纸满满让你充满安全感，你会偶尔分神片刻感谢保洁大爷的勤恳与认真。<br>我在碎片化的时间里读完了王小波的《黄金时代》。拉屎读王小波的书是最舒服的。这小子写东西看似随意，但也是思路清清晰晰毫不马虎，最主要的是想说啥就说啥，能用脏话表达出来的就用脏话。我也有时候怀疑这小子是不是偷偷读过我写的文章，模仿我的行文风格，让我越看越像是自己写的一样。我要是早出生几年，算是白瞎了一个王小波。这么想来，脸上的肉也不是白长的，无所谓，我也不是那么特别在意。</p>
<p>小波在书中讲了很多故事，总体就一个故事，他的黄金时代。黄金时代，有很多不成形的梦，然后被锤碎成玻璃碴子，在太阳下闪闪发光，发的别人的光。还好有锤碎的梦想，还好有被阉割锤扁的牛。这些都是遗憾，遗憾并不是你错过了没有把握住，而是没有能力把握住而错过了。等你有能力，回想起来，那就是遗憾。开始我以为黄金时代是对于整个国家整个时代来讲的一个好时代，我错误的以为它是夸奖了一个民族的一个了不起的精神，其实很单纯，就是一个人的美好年纪。每个人都有自己的黄金时代，二十也好，三十也好。这个时间段感觉到想努力找不到方向，想放飞却又特别克制，想成功却又担心自己经受不起失败。你只是向往单纯的美好，那是你的黄金梦想。就像一头野驴，认为自己很强壮，它可能永远也想不到驴肉火烧配豆腐脑的美妙。渴望爱情，渴望钞票，当一切都实实在在呱呱地扇你大嘴巴子，你也是倔强的不闹不吵，连一头正在被阉割的牛都不如。<br>碎片化的时候也会读一些所谓文学家的作品，老舍的《济南的冬天》，你会觉得，这操蛋的肯定为了赚稿费凑字数。这么一来，练碎片化都没有兴趣。</p>
<p>小波的黄金时代就不同，他让你碎片化得特别通畅，通畅得忘了痔疮。所以我得替痔疮感谢一下小波老师，他文字的魔法我是效仿不来。</p>
<p>我觉得现在就是我的黄金时代，可以有精力有力气有心思去追求自己的理想国，可以在理想和现实之间挣扎，还是一块即将要被锤碎的玻璃，一头即将被锤扁阉割的牛。理想与现实，更现实一点。还保持着对爱情的羞涩，给喜欢的姑娘发消息会仔细斟酌，会在没事翻一下没多少的聊天记录，反思一下那句话不恰当。学会了借酒说话，其实明白的很。满足于自由，却也渴望有人一起说话，就像不小心摔倒，嘻嘻一笑，掏出手机，看，摔倒了，老子没哭。</p>
<p>工作呀，工作就更有意思了。蒙逼状态下被领导谈薪，一心想着刚才的代码怎么写才能像写诗一样，还会向老头子迫不及待分享喜悦。</p>
<p>在梦想没碎成玻璃渣子之前，努力保存他的完整。渴望成长，渴望被教育，渴望挫折，渴望千千万万，好多好多。</p>
<p>你就想，父母健在，上无需多虑；自己一人，下更不用关心。还有许多去争取，去尝试。无牵无挂，这正是我的黄金时代。</p>
<p>感谢王小波，让我提前意识到自己的环境定位，这些都是痔疮所不能告诉你的。由此见来，小波还是比痔疮强了不少。<br>最后，感谢我的黄金时代。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>并不孤独</title>
    <url>/2018/01/14/%E5%B9%B6%E4%B8%8D%E5%AD%A4%E7%8B%AC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 常用命令介绍</title>
    <url>/2017/10/28/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>是一个快速、简洁且高效的博客框架。Hexo使用<a href="https://daringfireball.net/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>利用Hexo和GitHub搭建<a href="（http://theme-next.iissnan.com/">Next</a>主题博客系统请参照Next的<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h2><p>Hexo等一系列搭建完成之后，可以轻松的进行博客撰写和发表。以下是一些常用的命令操作。</p>
<h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new post &quot;article title&quot;</span></pre></td></tr></table></figure>
<p>这样，就在主目录（对应git主目录）的 source/_post 目录里面新建了一个“article title.md”的markdown文件。可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo n &quot;article title&quot;</span></pre></td></tr></table></figure>

<h3 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span></pre></td></tr></table></figure>
<p>这个命令一般用于清理项目下的缓存，用于启动项目之前。</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>
<p>用于启动服务。这是什么意思呢？相当于你可以通过浏览器浏览你用markdown写的博客网站，当然是访问的本地环境。这就类似于启动tomcat访问项目。路由器的url路径填写localhost:4000。这样，就可以在本机调试博客网站。可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span></pre></td></tr></table></figure>
<p>关闭服务则为Ctrl+C。</p>
<h3 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>
<p>用于将新建的markdown文件解析为静态网页。一般用于新博客文章发布且启动服务之前。可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span></pre></td></tr></table></figure>
<p>监视文件变动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --watch</span></pre></td></tr></table></figure>

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>
<p>用于将完成的博客发布挂载到我们的GitHub上。<br>可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span></pre></td></tr></table></figure>

<h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><p>两个命令是相同的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --deploy</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo deploy --generate</span></pre></td></tr></table></figure>
<p>简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo d -g</span></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上是利用hexo新建发表博客的常用指令。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明手册——本地版本仓库</title>
    <url>/2017/10/28/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Git-简单介绍"><a href="#Git-简单介绍" class="headerlink" title="Git 简单介绍"></a><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 简单介绍</h3><p>Git作为目前世界上先进的分布式版本控制系统，具有很多优秀的特性，是SVN所不能比拟的。简单来讲，Git有一下几点优点：</p>
<h4 id="分布式管理"><a href="#分布式管理" class="headerlink" title="分布式管理"></a>分布式管理</h4><p>相比较于集中式管理的弊端，比如：版本库存储在中央服务器，每次开发都必须先从中央服务器将本机代码更新为服务器版本。这就好像你每次干活之前，都要先申请使用最新的工具一样。这也无可厚非，但是网络出现问题无法获取最新的工作场景，就会给以后的开发带来许多困扰。作为分布式管理的Git，则无需担心这个问题。可以这样理解，Git实现了去中心化，也就是每个人工作空间的版本和服务器的版本是一样的，每个人的工作台都可以理解为服务器。开发完各自的功能就可以提交代码，push到远程服务器。同时也可以更新本地代码为远程服务器的最新版本，pull拉回本地。当然，冲突不可避免。</p>
<h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>对于开发一个大型的应用，Git的分支管理则就派上了重大用场。对大型应用进行功能拆分，分解为几部分高内聚的功能，分发给相应的开发人员。此时不同的开发人员则就可以针对各自的功能部分从主分支拉取新分支进行开发，开发完成之后push到远程主分支，同时也可以pull拉取主分支上别人提交的代码。当然也可以将其他功能分支checkout到本地进行一些review等。除此之外，还可以针对bug进行临时拉取分支开发bug修复分支，修复完成后merge到主分支消除bug。</p>
<p>针对上述一些专业名词（push、pull、checkout等），将会逐渐讲解。  </p>
<h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>安装完git后，需要去<a href="https://github.com/" target="_blank" rel="noopener">Github</a>（俗称gayhub）注册账号，相当于在gay社区有一个自己gay的身份。这个gayhub是一个代码托管平台，可以将自己的代码托管到这个平台，相当于远程仓库，更通俗来讲，就是一个中央服务器。每个人都可以fork你的代码并clone到他们的主机。  </p>
<h4 id="配置信息设置"><a href="#配置信息设置" class="headerlink" title="配置信息设置"></a>配置信息设置</h4><p>将自己的gay信息注册到本地git软件。这样你就可以将本地开发完的代码提交到远程主分支，也就是远程服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;你的GitHub注册用户名&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git config --global user.email &quot;你的GitHub注册邮箱&quot;</span></pre></td></tr></table></figure>
<p>这样就将你的信息注册到了本地git中。<br>检查已有的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list</span></pre></td></tr></table></figure>
<h4 id="文件版本操作"><a href="#文件版本操作" class="headerlink" title="文件版本操作"></a>文件版本操作</h4><p>一切准备就绪之后，我们就可以进行本地git的一顿操作啦。</p>
<ul>
<li><p>初始化工作空间<br>创建一个文件夹作为项目的工作区，例如我在D盘创建了一个文件夹rushgit（创建文件夹命令：mkdir rushgit）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span></pre></td></tr></table></figure>
<p>此时，这个文件夹就成了我们git的一个工作区了。回头看一眼文件夹里面，git已经为我们生成了一个.git隐藏文件。对于这个git文件，它保存了我们整个工作区的版本历史、分支等一系列重要信息，尽量不要对它进行“操作”。</p>
</li>
<li><p>文件版本操作<br>有了工作空间，我们在此目录下进行的所有增删改查的操作都会被git“监控”并记录下来。接着我们随意创建一个文件并保存（touch java9.txt），文件中输入一行文本：“java 9于20177年9月21日正式发布。”。此时工作区已经发生了改变——添加了一个文件。此时我们输入git status（查看工作区的状态），让我们的小管家git告诉我们发生了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">on branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">Untracked files:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      (use <span class="string">"git add &lt;file&gt;..."</span> to include in what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    java9.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">nothing added to commit but untracked files <span class="title">present</span> <span class="params">(use <span class="string">"git add"</span> to track)</span></span></span></pre></td></tr></table></figure>
<p>此时git提醒我们，initial commit（初始提交）。Untracked files则是指java9.txt还未添加到git的版本控制区域，还未被追踪到。同时git还给出了我们接下来可能或者应该进行的操作，git add。将<file>添加进来提交。那么我们就跟着提示进行下一步。</file></p>
</li>
<li><p>将文件添加到暂存区<br>从status中我们了解到我们整个工作区的状态属于待添加的状态，我们就将文件添加一下，看是将文件添加到哪里。  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ git add java9.txt         # 将文件java9.txt添加到本地版本库</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add *.txt             # 将所有*.txt添加到本地版本库</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add .                 # 将所有的子目录（不包含空目录）到本地版本库</span></pre></td></tr></table></figure>
<p>此时再利用git status查看一下工作区的状态，提示则是提交初始化，意思就是可以提交了。但是提交到哪呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Initial commit</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes to be committed:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">new</span> file:   java9.txt</span></pre></td></tr></table></figure>
<p>这里就引入了git工作区和版本库的概念，如图：<img src="/2017/10/28/Git%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/git_work_version.jpg" alt="git工作区和版本库"></p>
<p>解释一下工作区和版本库的概念：通俗来讲，你编辑文本的整个目录，或者说你的整个工程项目，就是你的工作区。你在这里进行工程的开发。而版本库，则是你进行版本控制的地方，譬如你可以查看历史工作记录、操作回退等功能，有点类似于在此拥有ctrl+s、ctrl+z、ctrl+y的功能（针对版本而言）。当我们开发了一部分功能，可以使用<strong><em>git add 文件名</em></strong>将此部分工程添加到我们版本库的暂存区，可以认为这里是我们工程修改的一个中转站。使用<strong><em>git commit -m ‘说明’</em></strong> 可以将暂存区的所有修改同步到版本库，也就是分支、主干管理处。</p>
</li>
<li><p>将文件添加到版本库<br>从上面我们了解到add之后的status为initial commit，从git的提示信息我们可以了解到，此时处理可以提交（commit）的状态。什么是commit？就是将本地暂存区的修改记录全部同步到版本库当中，这也就是如上图所示的暂存区到版本库的状态转移。</p>
<ol>
<li>-m “注释”,git commit -m ‘此处为本次提交代码版本修改的注释’。</li>
<li>-a 表示将所有已跟踪文件执行修改或删除的文件状态同步到版本库。</li>
<li>-amend 表示追加提交，在不新增一个commit-id的情况下将新修改的代码追加到前一次的commit-id当中。</li>
</ol>
<p>一般我们只需要使用-m参数，显示指定当前提交的备注。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add java9&quot;</span></pre></td></tr></table></figure>
<p>此时我们再执行git status查看我们版本库的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">nothing to commit, working directory clean</span></pre></td></tr></table></figure>
<p>提示我们在分支master，当前没有需要提交的，工作区是干净的。这就完成了一次commie。此时可以通过git log查看提交记录，由于我们之提交了一次，所以会显示一次commit，并且跟着一串commit-id，这个commit-id可以追踪提交记录，每次提交都会产生新的一个commit-id用于标识本次的提交修改，以后会讲到根据commit-id来进行版本回退等的操作。</p>
</li>
<li><p>提交历史纪录<br>上面提到，使用<code>git log</code>可以查看版本提交的历史记录。但是记录显示的会比较乱，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">commit <span class="number">68</span>c86da5dc6372755fe7048847aed6cd9b8f001f  --- commit-id</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: VfEver &lt;******@***.com&gt;                  --- 提交人</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Mon Sep <span class="number">24</span> <span class="number">00</span>:<span class="number">49</span>:<span class="number">54</span> <span class="number">2018</span> +<span class="number">0800</span>           --- 提交日期</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add java9                                    --- 提交注释</span></pre></td></tr></table></figure>
<p>从上面可以看到比较凌乱，尤其是在提交历史多了以后，更是不好定位。所以还有一个命令，使得我们查看版本提交记录更加简洁明了。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty&#x3D;oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ 68c86da5dc6372755fe7048847aed6cd9b8f001f add java9</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本小节我们主要学习了git的配置、暂存区、版本库的概念，以及添加到暂存区、版本库的常用命令。接下来我们主要将要接触远程仓库——和大家一起玩。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>在北京这狗日的一百天里</title>
    <url>/2017/10/19/%E5%9C%A8%E5%8C%97%E4%BA%AC%E8%BF%99%E7%8B%97%E6%97%A5%E7%9A%84%E4%B8%80%E7%99%BE%E5%A4%A9%E9%87%8C/</url>
    <content><![CDATA[<p>来北京应该有一百天了。  </p>
<p>七月二十一号入职，最近提交了转正申请，算是正式成为一个上班人了。  </p>
<p>在这狗日的一百天里，自己总是觉得还是一个学生，痞里痞气的想上学就上学想睡觉就睡觉的念头老是浮现，也超级怀念那种轻松惬意的日子。但是工作却像你屁股上的痔疮，总是督促你勤走路，多喝水，大号不玩手机一样。是的，像是一杆温柔的枪，在你舒适惬意的念头里，指着你，“兄弟，你忘了你的痔”，让你想起撕心裂肺的那一周。工作也是，不是好事情，却温柔的抚摸着你，“狗日的，上班去”。  </p>
<p> 最开心的日子是周五下班的晚上，感觉回家的路上，连耳旁的风都在欢快地喊着“爸爸，爸爸，放假啦快回家”。只要今夜不睡，周五就不会悄悄溜走。但是美好的日子总是走的太快，安安稳稳睡一觉就到了周天下午。就感觉妈的还没开始就结束了，这使得周末的日子格外珍贵，就像不脱落的痔。  </p>
<p>当然，周五下班有多欢快，周天下午就有多悲怆。宁静的午后，空气悲怆的都快凝结，像是透过厚厚的棉花呼吸着。就安安稳稳的坐在椅子上，看着时钟，滴答滴答，像是赶着上刑的囚车，前方不远处就是断头台。那感觉，贼鸡儿难受。一般这个时候，我都会带上手机耳机，下楼去扫辆单车，一直骑到六环外，看看北京的郊区。这样漫无目的的骑着车，从一个小村骑到另一个小村，也没什么风景，也可能没什么好心情。但总是很珍惜这一小会儿的时光，感觉这是天人合一最重要的时刻。  </p>
<p>突然，盼着周五，讨厌着周一，三个月也就过去了，不是从指缝中，也不是从眼镜度数涨65°中，还不是体重疯长三公斤中。二十你把转正申请写完提交，发现妈的以后要有责任心了。对工作也好，对生活也好，对爸妈也好，对自己也好。一百天里，分清了生抽和老抽，然后被室友疯狂嘲讽鸡蛋炒一切；一百天里，写了一百天的JSP，感觉像是一个疯狂原始人；一百天里，感受到了房子和车子，也像是一杆温柔的枪。  </p>
<p>未来很难啊，生活很难啊，可是我现在对他们的理解一点点都不到位。觉得未来就在那，你看得到；生活就在这，你感受的到。都还好。所以我坚持没有吃过生活的苦，不能称之为理解生活。当然，大便臭不臭不是吃出来的。  </p>
<p>现在凌晨两点半，坐在公司的工位上，看着压测数据，想着在这狗日的一百天里自己的所作所为。  </p>
<p>要成为正式员工了，不能随便跑了，就很苦。但是没有关系啊。<br>未来要买房买车了，不能随便不上班了，就很苦啊。但是没有关系啊。<br>还没有妹子啊。但是没有关系啊。<br>没有关系啊！  </p>
<p>反正老子年轻，<br>反正老子牛逼。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>嘿，老兄。好久不见！</title>
    <url>/2017/08/13/%E5%98%BF%EF%BC%8C%E8%80%81%E5%85%84%E3%80%82%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/</url>
    <content><![CDATA[<p>我自认为自己是一个极其有条理且稍微有点强迫症的人。<br>说这句话的人，感觉也是正处于成熟与不成熟之间，并且自我感觉良好且自认为很成熟。不管怎样，暂且这样定义自己。  </p>
<p>有时候晚上睡眠不好，于是经常买些牛奶来喝。上学那段时间经常和暠冉拼单一起买牛奶喝。1L*6的牛奶一般的价位是45左右，有时候赶上京东搞活动，最便宜能用29块钱买到荷兰的纯牛奶。有一次就是凑巧一下子买了两箱1*6的，晚上下单第二天到了，然后我和暠冉出学校吃饭。旭辉和浩升帮我们从京东派搬回宿舍。当时很感激，一箱子牛奶6L还是挺重的，倒还没累死那俩傻逼。前段时间在天猫硬是凑单买了90多的生活用品，其中就包括一箱子牛奶。后来在京东一搜发现价格更便宜。对，京东的广告打的就是这么硬。  </p>
<p>大四寒假那会儿还是什么时候，看了一部宫崎骏的龙猫。被里面的人物感动的一塌糊涂，特别怀念童年。于是将自己的QQ网名从格格巫一个大坏蛋的名字改为多多洛。多多洛是日本龙猫的学名吧。借此怀念小时候的无忧时光。因为刚搬来北京这会买了个小桌子，想再买一个能盖住整个桌子的鼠标垫。在淘宝搜了很久，终于找到了一款70*30的上面印着龙猫图案的鼠标垫，很是喜欢。嗯，卖家发货发了一周。拿到手之后挺喜欢，能铺满大半个桌子。看书之余，我经常盯着那只龙猫看。心想，什么时候我也可以趴在它的肚子上睡觉。  </p>
<p>在学校没钱那会，买了一本盗版技术书关于linux的。书拿到书后很整齐，也挺喜欢。每次读几页，虽没什么收获，但是也没把书弄皱。很爱惜这本书，甚至给它做了一个简略的书签，每次读完，放上书签，不愿折书。我想，我这虔诚之心，也是想把书里的内容尽快掌握吧。  </p>
<p>刚才洗完澡，倒了一杯牛奶放在桌子左上角。坐在书桌前，瞅会龙猫，再看会书。突然觉得挺热，起身准备打开空调。左手放下遥控器，转身坐下时，右手碰翻的桌子上的牛奶。牛奶完完整整的洒在了鼠标垫和linux书上。我嘿嘿笑了起来。  </p>
<p>只见浓浓的牛奶盖满了书的大半页，那只龙猫也喝了小半杯的牛奶。  </p>
<p>来北京这段时间，我一直坚持着用扇贝记一下单词。每次记完当天的单词，都会跟着一段五六分钟的小视频。前几天记完单词，看到一个挺有意思的视频。大意是不论什么人，大人也好，小孩也好，都会不小心犯一些错误。我们总是极力避免自己犯一些错误，可是有时候事情总是事与愿违。比如吃完饭菜叶粘在牙齿，打翻杯子，系错扣子，裤子忘拉拉链。每次这些蠢事情发生时，我们总是责怪自己，还是像小孩子一样没有脑子。我们期望自己成熟，现实往往不是如此，总是觉得自己没有别人干练。其实每个人都是这样，只不过我们把自己的行为放大。而这些行为，都是自己内心小孩子在作怪。我们渴望成熟，拒绝幼稚，甚至将自己那些不成熟封杀在心底，不愿也不想让它出现。其实是不对的。偶尔允许自己的小孩子放纵，不经意的发现，咦，小伙伴又出来了。  </p>
<p>打翻杯子牛奶撒了一本子，我嘿嘿一笑。<br>老兄，好久不见。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾</title>
    <url>/2017/04/19/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/</url>
    <content><![CDATA[<p>昨晚闲来无事，多看阅读上找来一本鲁迅的《朝花夕拾》来打磨时间。  </p>
<p>第一篇便是“狗·猫·鼠”，讲来了“仇猫”的前前后后。读到中国官兵剿匪的做法，就又想到了初中时候写的一篇感悟。为了得到重视，为了得到长期的重用，官兵们总是不肯扫清土匪或扑灭敌人。鲁迅先生说，如果能将这方法推广应用，他就可以成为所谓“指导青年”的“前辈”。  </p>
<p>那时我觉得鲁迅所言极是，我知道他讽刺，但是我更是赞同先生的想法。而且，也是真真切切认为那也是先生的真实想法。现在想来也是。当时那位语文老师，课堂上和我探讨鲁迅先生的真实意图。我一直坚信我的想法正确。认为鲁迅先生确实可以这么做，官兵们也是这么做。现在也应该如此。当时那位女老师笑着给我解释，鲁迅一般是讽刺。所以，这个也是。  </p>
<p>我并没有认同。那位老师课下在图书馆给我借了一本鲁迅的杂文集，让我好好研读。  </p>
<p>她说我的文笔有点像鲁迅。可能是我瞎想瞎写魔怔了吧。<br>现在想来，那位语文老师是我学生生涯当中最可敬的一位老师之一。尊敬和负责，这是我对她的所有印象。  </p>
<p>不管到底仇不仇猫，不管到底反不反讽。  </p>
<p>细细算来，到如今，<br>九年过去了。<br>以前不懂，现在还是不懂。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
